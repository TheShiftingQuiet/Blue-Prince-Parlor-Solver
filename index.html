<!DOCTYPE html>
<html lang="en">

<head>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
<meta name="google-site-verification" content="yWIwJYlQ8faIP56kh9RW-Idj4AeMLwZTncl3cif3tmY" />
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Parlor Solver: a tool to help you solve the parlor puzzles from the game Blue Prince using rule-based boolean logic.">

<meta property="og:title" content="Parlor Puzzle Solver | Blue Prince" />
<meta property="og:description" content="Solve the parlor logic puzzles from Blue Prince using this interactive, rule-based boolean logic deduction tool." />
<meta property="og:url" content="https://theshiftingquiet.github.io/Blue-Prince-Parlor-Solver/" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://theshiftingquiet.github.io/Blue-Prince-Parlor-Solver/preview.png" />
<meta property="og:site_name" content="Parlor Puzzle Solver | Blue Prince" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Parlor Puzzle Solver | Blue Prince" />
<meta name="twitter:description" content="Solve the parlor logic puzzles from Blue Prince using this interactive, rule-based boolean logic deduction tool." />
<meta name="twitter:image" content="https://theshiftingquiet.github.io/Blue-Prince-Parlor-Solver/preview.png" />

<meta name="keywords" content="parlor puzzle, parlor solver, parlor puzzle solver, parlor hints, parlor room, parlor boxes, boxes puzzle, Blue Prince, Blue Prince parlor puzzle">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E6ESL8H13E"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E6ESL8H13E');
</script>
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Parlor Puzzle Solver | Blue Prince",
    "url": "https://theshiftingquiet.github.io/Blue-Prince-Parlor-Solver/",
    "description": "Solve the parlor logic puzzles from Blue Prince using this interactive, rule-based boolean logic deduction tool.",
    "applicationCategory": "GameUtility",
    "operatingSystem": "All",
    "browserRequirements": "Requires JavaScript",
    "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
    }
}
</script>

<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
        {
            "@type": "Question",
            "name": "How do I solve the parlor box puzzles?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "You can use this tool to evaluate all possible cases automatically given the box statements, rather than doing it by hand. Doing so will always give you the correct answer."
            }
        },
        {
            "@type": "Question",
            "name": "Are the parlor puzzles infinite?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "The puzzles are not infinite, but they do seem to be randomized (or there are a large set of them). Most of them don't have answers posted online, but you can use this tool to solve them."
            }
        },
        {
            "@type": "Question",
            "name": "Does the parlor puzzle keep getting harder?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "The parlor puzzles get as hard as 3 statements per box, but they do seem to reset or start getting easier every now and then."
            }
        }
    ]
}
</script>

<meta name="robots" content="index, follow">
<link rel="canonical" href="https://theshiftingquiet.github.io/Blue-Prince-Parlor-Solver/" />

<script src="jexl.browser.js"></script>
<title>Parlor Solver | Blue Prince</title>
<style>
    body {
        font-family: sans-serif;
        margin: 0;
        padding: 20px;
    }

    .box-toggle-groups {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        width: 100%;
        margin: 10px 0;
        gap: 20px;
    }
    input {
        width: 100%;
        margin: 2px 0;
    }
    button {
        margin-right: 5px;
    }
    .effects-container {
        display: flex;
        flex-wrap: wrap;
        flex-direction: row;
        margin-top: 10px;
    }
    .effects {
        margin-top: 10px;
        margin-right: 50px;
    }
    .toggle-group {
        display: flex;
        align-items: center;
        width: 220px;
        justify-content: flex-end;
    }

    .toggle-label {
        font-weight: bold;
        align-self: center;
    }

    .button-group {
        min-width: 118px;
        margin-left: 10px;
        margin-right: 40px;
        display: flex;
        flex-direction: column;
    }

    .button-group.horizontal {
        flex-direction: row;
    }

    button {
        padding: 6px 14px;
        margin-right: 6px;
        border: 1px solid #888;
        background-color: #f0f0f0;
        cursor: pointer;
        border-radius: 4px;
        font-size: 14px;
        user-select: none;
        transition: background-color 0.2s, color 0.2s;
    }

    button:hover {
        background-color: #e0e0e0;
    }

    .toggle-button {
        margin-right: 6px;
    }

    .toggle-button.active {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
    }

    .statement-block {
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 10px;
        margin-top: 12px;
        background-color: #fafafa;
        color: black;
    }

    .statement-block h4 {
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 16px;
        border-bottom: 1px solid #ddd;
        padding-bottom: 4px;
    }

    .statement-grid {
        display: grid;
        grid-template-columns: 1fr 2fr;
        gap: 6px 12px;
        align-items: center;
    }

    .statement-grid label {
        font-weight: 500;
    }

    .statement-grid input {
        width: 100%;
        font-family: monospace;
        font-size: 14px;
        padding: 4px;
        box-sizing: border-box;
    }

    .statement-compact-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 6px;
        font-size: 14px;
    }

    .statement-compact-table th,
    .statement-compact-table td {
        padding: 4px 6px;
        border: 1px solid #ddd;
        vertical-align: middle;
    }

    .statement-compact-table input {
        width: 100%;
        font-family: monospace;
        font-size: 14px;
        box-sizing: border-box;
    }

    .controls {
        margin-top: 20px;
        display: flex;
        justify-content: center;
        width: 100%;
    }

    .other-settings-optional-labels {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 15px 0;
    }

    .optional-label-inputs {
        width: 100%;
    }

    .optional-label-inputs .toggle-button {
        width: 50%;
        max-width: 200px;
    }

    .optional-label-inputs.button-group {
        justify-content: center;
        margin-top: 5px;
    }

    #inputArea {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
    }

    .box {
        border: 1px solid #aaa;
        padding: 10px;
        flex: 1 1 300px;
        min-width: 300px;
        max-width: 100%;
        box-sizing: border-box;        
    }

    .box:nth-child(1) {
        background-color: #9dc9ff;
    }
    .box:nth-child(2) {
        background-color: #ffffff;
    }
    .box:nth-child(3) {
        background-color: #2e2e2e;
        color: white;
    }

    .case {
        margin: 10px 0;
        border: 2px solid #333;
        padding: 10px;
        background-color: #ccffcc
    }

    #outcomeSummary {
        margin: 10px 0;
        border: 2px solid #333;
        padding: 10px;
    }

    #outcomeSummary.found-answer {
        background-color: #ccffcc;
    }

    #outcomeSummary.no-answer {
        background-color: #ffcccc;
    }

    #outcomeSummary.ambiguous-answer {
        background-color: #d5b1de;
    }

    #outcomeText {
        white-space-collapse: preserve;
    }

    .case.invalid-case {
        background-color: #ffcccc;
    }

    .case.ambiguous-case {
        background-color: #d5b1de;
    }
    
    .highlight-false {
        background-color: yellow;
    }

    .case .effect-false {
        color: red;
    }

    .case .effect-true {
        color: green;
    }

    .reasoning li {
        white-space-collapse: preserve;
        margin-bottom: 10px;
    }

    #helpModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        z-index: 1000;
        padding: 50px;
        box-sizing: border-box;
        justify-content: center;
        align-items: center;
    }

    #helpModalInner {
        background: white;
        border-radius: 8px;
        width: 100%;
        height: 100%;
        max-width: 100%;
        max-height: 100%;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        box-sizing: border-box;
    }

    #helpModalHeader {
        flex: 0 0 auto;
        padding: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: white;
        z-index: 1;
    }

    #helpModalContent {
        flex: 1 1 auto;
        overflow-y: auto;
        padding: 0 20px 20px 20px;
        box-sizing: border-box;
    }

    .autogenerated {
        background-color: #edffef;
        border: 1px solid #2390f2;
        color: #7b7b7b;
        border-style: dashed;
    }

    .label-col.hidden-col {
        display: none;
    }

    h1 {
        font-size: 1.2rem;
        margin: 0 0 1.2rem 0;
        font-weight: 600;
        text-align: center;
    }

    #footer {
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 1px solid #dad3d3;
        width: 100%;
        text-align: center;
    }

    #faq-header {
        margin-top: 2rem;
        font-size: 1.2rem;
        font-weight: 600;
        text-align: center;
    }

    #faq {
        font-size: 1.2rem;
    }

    #faq details {
        margin: 10px 0;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 8px;
        background-color: #f9f9f9;
    }

    #faq summary {
        cursor: pointer;
        font-weight: bold;
    }
</style>
</head>

<body>
    <h1>Blue Prince: Parlor Puzzle Solver</h1>
    <div class="setup-controls">
        <div class="box-toggle-groups">
            <div class="toggle-group">
                <div><label class="toggle-label">Blue:</label></div>
                <div class="button-group" data-name="blueCount">
                    <button class="toggle-button" data-value="0">Blank box</button>
                    <button class="toggle-button" data-value="1">1 statement</button>
                    <button class="toggle-button active" data-value="2">2 statements</button>
                    <button class="toggle-button" data-value="3">3 statements</button>
                </div>
            </div>
            <div class="toggle-group">
                <div><label class="toggle-label">White:</label></div>
                <div class="button-group" data-name="whiteCount">
                    <button class="toggle-button" data-value="0">Blank box</button>
                    <button class="toggle-button" data-value="1">1 statement</button>
                    <button class="toggle-button active" data-value="2">2 statements</button>
                    <button class="toggle-button" data-value="3">3 statements</button>
                </div>
            </div>
            <div class="toggle-group">
                <div><label class="toggle-label">Black:</label></div>
                <div class="button-group" data-name="blackCount">
                    <button class="toggle-button" data-value="0">Blank box</button>
                    <button class="toggle-button" data-value="1">1 statement</button>
                    <button class="toggle-button active" data-value="2">2 statements</button>
                    <button class="toggle-button" data-value="3">3 statements</button>
                </div>
            </div>
        </div>
        <div class="other-settings">
            <div class="other-settings-optional-labels">
                <div>Show optional label inputs? They are just for your own reference.</div>
                <div class="button-group horizontal optional-label-inputs" data-name="optionalLabelInputs">
                    <button class="toggle-button active show-hide-label-btn" data-value="0">Hide</button>
                    <button class="toggle-button show-hide-label-btn" data-value="1">Show</button>
                </div>
            </div>
        </div>
    </div>
    <div id="inputArea"></div>
    <div class="controls">
        <button onclick="calculate()">Calculate</button>
        <button onclick="clearCalculations()">Clear calculations</button>
        <button onclick="clearAll()">Clear all</button>
        <button onclick="openHelpModal()">Help</button>
    </div>
    <div id="outcomeSummary" style="display: none;">
        <h3>Outcome</h3>
        <p id="outcomeText"></p>
    </div>
    <div id="cases"></div>

    <div id="faq">
        <h2 id="faq-header">Frequently Asked Questions</h2>
        <details>
            <summary>What are the inputs? What is the If TRUE condition, and what is the If FALSE condition for?</summary>
            <p>The inputs are the statements for each box.</p>
            <p>Basically, the tool is going to go through all possible combinations and evaluate each of the statements with the assumed truthfulness, to see if it leads to a contradiction.</p>
            <p>So, for the If TRUE condition - you write the logic that would follow if the statement is assumed to be true.</p>
            <p>For the If FALSE condition - you write the logic that would follow if the statement is assumed to be false.</p>
            <p>You might ask, aren't the FALSE conditions just the negation of the TRUE conditions? Yes. But sometimes, the negation is a logical paradox - you can write <code>false</code> for those cases, for example.</p>
            <p>That said, in most cases, the negation is just the same as the TRUE condition but negated, so it will be generated automatically for you as you write the If TRUE condition- but you can override it.</p>
        </details>
        <details>
            <summary>How do I write the JEXL logical expressions?</summary>
            <p>The expressions are JEXL (JavaScript Expression Language) expressions, which is pretty similar to JavaScript. For example, you can use <code>white.isEmpty || (black.isAllTrue && black.hasGems)</code> to represent a statement like "the white box is empty or the black box is true AND contains gems".</p>
            <p>You can find more examples in the Help modal.</p>
            <p>If you'd like to read up more on how to write JEXL statements, you can do so <a href="https://github.com/TomFrost/jexl">here</a>, though the examples should be more than enough to get you started, and most of the basic JS syntax will work as you would expect it.</p>
            <p>Your JEXL condition will have access to the following objects (and each will have a different value when considering each possibility) - blue, white, black, each object with:</p>
            <pre><code>{
    "color": "blue" or "white" or "black",
    "oneIsTrue": true if blue 1 statement is assumed true in this case, false otherwise,
    "oneIsFalse": true if blue 1 statement is assumed false in this case, false otherwise,
    "twoIsTrue": true if blue 2 statement is assumed true in this case, false otherwise,
    "twoIsFalse": true if blue 2 statement is assumed false in this case, false otherwise,
    "threeIsTrue": true if blue 3 statement is assumed true in this case, false otherwise,
    "threeIsFalse": true if blue 3 statement is assumed false in this case, false otherwise,
    "labels": array of strings, each representing the label of the statement in this box (labels[0] = blue 1 label, labels[1] = blue 2 statement, etc.)
    "bools": array of booleans, each representing the truthiness of the statement in this box (bools[0] = blue.oneIsTrue, bools[1] = blue.twoIsTrue, etc.)
    "isAllTrue" or "isTrue" or "allIsTrue": true if all of the statements in this box are assumed true in this case, false otherwise
    "isAllFalse" or "isFalse" or "allIsFalse": true if all of the statements in this box are assumed false in this case, false otherwise
    "isMixed": true if this box has at least one true and at least one false statement (so it's neither an all-true nor all-false box)
    "trueCount": number of statements that are assumed true in this case
    "falseCount": number of statements that are assumed false in this case
    "isEmpty" or "empty" or "hasNoGems": true if this sub-case assumes it's empty
    "hasGems" or "notEmpty" or "isNotEmpty": true if this sub-case assumes it has gems
}</code></pre>
                        <p>You will also have access to the object "context" with the following properties:</p>
                        <pre><code>{
    "trueBoxCount" or "allTrueBoxCount": number of boxes that are assumed to have only true statements in this case
    "falseBoxCount" or "allFalseBoxCount": number of boxes that are assumed to have only false statements in this case
    "trueStatementCount": number of statements that are assumed true in this case across all boxes
    "falseStatementCount": number of statements that are assumed false in this case across all boxes
    "boxWithGems": a reference to the box object that is assumed to have gems in this sub-case
    "boxesWithoutGems" or "emptyBoxes": an array of references to the box objects that are assumed to be empty in this sub-case
}</code></pre>
        </details>
        <details>
            <summary>How do I deal with statements that just don't make any sense?</summary>
            <p>A statement like "this box is of no help at all", for example, right?</p>
            <p>That's somewhat of a subjective box, but most of those boxes are usually false, or paradoxical enough to be considered false.</p>
            <p>For those, you can provide <code>false</code> as the condition for the TRUE case, and <code>true</code> as the condition for the FALSE case, which would mean that this statement cannot be true (but it logically works if we assume it's false).</p>
        </details>
        <details>
            <summary>How does the tool work?</summary>
            <p>Essentially, it goes through all 6-18+ possible combinations of 1-3 true/false statements.</p>
            <p>Then, for each case, goes through all 3 possible gem placements.</p>
            <p>It evaluates each statement with its assumed truthfulness.</p>
            <p>If any of the statements evaluate to false - that's a contradiction.</p>
            <p>If any of the 3 possible gem placements work out with no contradictions across all statements - that's a valid answer.</p>
            <p>In the end, if there's only one valid answer - that's your definitive answer.</p>
            <p>If there's multiple - there's some sort of ambiguity that you can resolve by looking at the page's reasoning for each of the cases.</p>
            <p>If there are none - there must be some logical error in how some of the statements are constructed.</p>
        </details>
        <details>
            <summary>I'm getting an ambiguity error</summary>
            <p>The parlor puzzles are designed in a way that they can be solved with logic, without any guessing necessary.</p>
            <p>This means, if you are getting an ambiguity - there is something missing: perhaps you made a typo in one of the statements, perhaps you missed a statement, maybe you missed a constraint that a statement implies, perhaps you misinterpreted the statement.</p>
            <p>If you have any questions, or if you feel like the tool isn't working as expected, feel free to post an issue on Github.</p>
        </details>
        <details>
            <summary>I'm getting a no possible answers error</summary>
            <p>The parlor puzzles always have at least one possible answer, so if you're getting a 0 possible answers error - there is something wrong with the statements.</p>
            <p>Double-check all your statements and make sure they are all logically consistent, and that you're not adding some constraint that isn't implied by the statements.</p>
            <p>For example, think about the statement "a box next to this box has only true statements". That does not imply that there are no false boxes next to the box - just that there is SOME box next to it that has only true statements.</p>
        </details>
        <details>
            <summary>I'm getting an alert with some JEXL error</summary>
            <p>You must have made some syntax error in the JEXL expression, or perhaps you tried accessing a property that doesn't exist.</p>
            <p>To prevent common typos, I've made it so that access to properties that don't exist will throw an error, rather than returning undefined.</p>
            <p>That's because you wouldn't want <code>white.iSTrue</code> to return undefined (falsy), even though <code>white.isTrue</code> may have been true.</p>
        </details>
        <details>
            <summary>JEXL doesn't support some advanced functions I'm trying to use</summary>
            <p>JEXL is more of a subset of JavaScript, so it doesn't support all of the functions you might be used to.</p>
            <p>Though, you can always add your own functions to JEXL, if you are familiar enough with JavaScript.</p>
            <p>For example, you could add a function <code>countAllWords</code> by opening the devtools console and typing like this:</p>
            <pre><code>
                Jexl.addFunction('countAllWords', box => {
                    return box.labels.reduce((acc, label) => acc + (label ? label.split(' ').length : 0), 0);
                });
            </code></pre>
            <p>You could then use it in your JEXL expressions like this:</p>
            <pre><code>
                countAllWords(blue) > 1
            </code></pre>
        </details>
        <details>
            <summary>What are the optional labels for?</summary>
            <p>The labels are just for your own reference. They don't affect the logic of the statements in any way.</p>
            <p>Basically, if you plan to look through each of the possible cases to troubleshoot - you can write the labels there to help you remember what each statement means.</p>
            <p>You can also access these labels through the JEXL statements in case you got a statement like "The box with more than 8 words" and you don't want to count by hand.</p>
        </details>
        <details>
            <summary>The statement is too complex to represent it as a JEXL statement</summary>
            <p>Usually, even when it feels like it's hard to translate it into a logical statement - it is still possible, without any loss of data.</p>
            <p>For example, if it says "a box next to this box has only true statements" - you don't need to try and figure out how to represent "next to" in a logical statement.</p>
            <p>Instead, you can simply look at which boxes are next to this box, then, let's say it's the blue and black boxes - write: <code>blue.isAllTrue || black.isAllTrue</code>.</p>
        </details>
        <details>
            <summary>How do I share my inputs with someone, do I have to copy-paste each statement?</summary>
            <p>You can share your inputs with someone by copying the URL of the page after you have filled out the inputs and pressed Calculate.</p>
            <p>When you hit Calculate, the page will generate a unique URL that contains all of your inputs and the calculated results and append it to the URL.</p>
            <p>This is also edited into your navigation history, so if you refresh or go back - your inputs will be preserved.</p>
        </details>
        <details>
            <summary>I would like to contribute to the project, report a bug, viuew the source code, or suggest a feature</summary>
            <p>You're more than welcome to open an issue or a pull request <a href="https://github.com/TheShiftingQuiet/Blue-Prince-Parlor-Solver">in the Github repository!</a></p>
        </details>
    </div>

    <footer id="footer">
        <p>You can find the source code <a href="https://github.com/TheShiftingQuiet/Blue-Prince-Parlor-Solver">in the Github repository</a></p>
    </footer>

    <div id="helpModal">
        <div id="helpModalInner">
            <div id="helpModalHeader">
                <h2>Instructions</h2>
                <button id="closeHelpModalBtn" onclick="closeHelpModal()" style="margin-top: 20px;">Close</button>        
            </div>
            <div id="helpModalContent">
                <p>You know the rules for the parlor already from Blue Prince.</p>
                <p>You need to choose the number of statements you have for each of the three boxes, as well as filling out the statements:</p>
                <ul>
                    <li><strong>Label (optional)</strong>: the label. For the True case - this can be the statement on the box, verbatim. For the False case - this would be the negation: "(the statement) is not true". In most cases, you can word the negation more clearly.</li>
                    <li><strong>Condition (JS/JEXL)</strong>: A JEXL expression that evaluates to a truthy value if the statement is logically consistent with the assumption, or a falsy value if it contradicts it. Typically, the False version for this is just the same as the True variant but negated, but sometimes you might want to write 'false' if the statement contradicts itself (like "every statement with the word empty is false" - that statement cannot be true by definition).</li>
                </ul>

                <p>The script go through each possible combination of which statements are true/false, e.g. blue statement 1 is True, blue statement 2 is True, white statement 1 is False, white statement 2 is True, black has one statement and it's False.</p>
                <p>For each combination (case), it will consider 3 possibilities: gems are in the blue box, gems are in the white box, and gems are in the black box.</p>
                <p>For each of those possibilities, it will evaluate the JEXL conditions for the assumption and if any of the possibilities has all of the JEXL conditions returning true - that's a valid case. Else, it shows the contradiction.</p>            
                <p>Your JEXL condition will have access to the following objects (and each will have a different value when considering each possibility) - <code>blue</code>, <code>white</code>, <code>black</code>, each object with:</li>
                </ul>
                <pre><code>{
    "color": "blue" or "white" or "black",
    "oneIsTrue": true if blue 1 statement is assumed true in this case, false otherwise,
    "oneIsFalse": true if blue 1 statement is assumed false in this case, false otherwise,
    "twoIsTrue": true if blue 2 statement is assumed true in this case, false otherwise,
    "twoIsFalse": true if blue 2 statement is assumed false in this case, false otherwise,
    "threeIsTrue": true if blue 3 statement is assumed true in this case, false otherwise,
    "threeIsFalse": true if blue 3 statement is assumed false in this case, false otherwise,
    "labels": array of strings, each representing the label of the statement in this box (labels[0] = blue 1 label, labels[1] = blue 2 statement, etc.)
    "bools": array of booleans, each representing the truthiness of the statement in this box (bools[0] = blue.oneIsTrue, bools[1] = blue.twoIsTrue, etc.)
    "isAllTrue" or "isTrue" or "allIsTrue": true if all of the statements in this box are assumed true in this case, false otherwise
    "isAllFalse" or "isFalse" or "allIsFalse": true if all of the statements in this box are assumed false in this case, false otherwise
    "isMixed": true if this box has at least one true and at least one false statement (so it's neither an all-true nor all-false box)
    "trueCount": number of statements that are assumed true in this case
    "falseCount": number of statements that are assumed false in this case
    "isEmpty" or "empty" or "hasNoGems": true if this sub-case assumes it's empty
    "hasGems" or "notEmpty" or "isNotEmpty": true if this sub-case assumes it has gems
}</code></pre>
                <p>You will also have access to the object "context" with the following properties:</p>
                <pre><code>{
    "trueBoxCount" or "allTrueBoxCount": number of boxes that are assumed to have only true statements in this case
    "falseBoxCount" or "allFalseBoxCount": number of boxes that are assumed to have only false statements in this case
    "trueStatementCount": number of statements that are assumed true in this case across all boxes
    "falseStatementCount": number of statements that are assumed false in this case across all boxes
    "boxWithGems": a reference to the box object that is assumed to have gems in this sub-case
    "boxesWithoutGems" or "emptyBoxes": an array of references to the box objects that are assumed to be empty in this sub-case
}</code></pre>
                <h3>Example:</h3>
                <p>If you're doing the TRUE js condition for the statement "the white box is empty", then use the following JEXL condition:</p>
                <code>white.isEmpty</code><br>
                <p>If you're doing the FALSE js condition for the statement "every statement with the word "empty" is false", the negation of which would be "at least one statement with the word "empty" is true", and assuming the statements that contain the word "empty' are blue 1, white 1, white 2 and black 1, then use the following JEXL condition:</p>
                <code>blue.oneIsTrue || white.oneIsTrue || white.twoIsTrue || black.oneIsTrue
            </div>
        </div>
    </div>

</body>

<script>
const maxPossibleStatements = 3;
const boxNames = ['Blue', 'White', 'Black'];
// just a sanity check - we make sure none of the box names include any HTML characters, since we treat this as safe
const unsafeChars = ['<', '>', '&', '"', "'", '`'];
boxNames.forEach(boxName => {
    if (unsafeChars.some(char => boxName.includes(char))) {
        let err = `Box name "${boxName}" contains unsafe characters.`;
        console.error(err);
        alert(err);
        throw new Error(err);
    }
});

function escapeHTML(str) {
    return str.replace(/[&<>"']/g, match => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
    }[match]));
}

const state = {
    inputs: {},
    cases: [],
    // we keep track of the last known JS codes for each box and statement for reasons you can find in the onTrueJsConditionBlur function
    lastTrueJsCodes: {},
};

function getStatementsCount(boxName) {
    return parseInt(document.querySelector(`.button-group[data-name="${boxName.toLowerCase()}Count"] .toggle-button.active`).dataset.value);
}


function generateInputs() {
    const inputArea = document.getElementById('inputArea');

    boxNames.forEach(boxName => {
        const count = getStatementsCount(boxName);

        let boxDiv = document.querySelector(`#box_${boxName}`);
        if (!boxDiv) {
            boxDiv = document.createElement('div');
            boxDiv.classList.add('box');
            boxDiv.id = `box_${boxName}`;
            boxDiv.innerHTML = `<h3>${boxName}</h3>`;
            for (let i = 0; i < maxPossibleStatements; i++) {
                const statementBlock = document.createElement('div');
                statementBlock.classList.add('statement-block');
                statementBlock.id = `${boxName}_statement_${i + 1}`;
                let labelClasses = `label-col${optionalLabelsColIsHidden() ? ' hidden-col' : ''}`;
                statementBlock.innerHTML = `
                    <h4>Statement ${i + 1}</h4>
                    <table class="statement-compact-table">
                        <thead>
                            <tr>
                                <th></th>
                                <th class="${labelClasses}">Label (optional)</th>
                                <th>Condition (JS/JEXL)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>If TRUE</strong></td>
                                <td class="${labelClasses}"><input type="text" id="${boxName}_s${i + 1}_true_label" /></td>
                                <td><input type="text" id="${boxName}_s${i + 1}_true_code" oninput="onTrueJsConditionModified('${boxName}', ${i + 1})" /></td>
                            </tr>
                            <tr>
                                <td><strong>If FALSE</strong></td>
                                <td class="${labelClasses}"><input type="text" id="${boxName}_s${i + 1}_false_label" /></td>
                                <td><input type="text" id="${boxName}_s${i + 1}_false_code" oninput="onFalseJsConditionModified('${boxName}', ${i + 1})" /></td>
                            </tr>
                        </tbody>
                    </table>
                `;
                boxDiv.appendChild(statementBlock);
            }
            inputArea.appendChild(boxDiv);
        }

        for (let i = 0; i < maxPossibleStatements; i++) {
            const block = document.getElementById(`${boxName}_statement_${i + 1}`);
            block.style.display = (i < count) ? '' : 'none';
        }
    });
}

function toggleOptionalLabelInputs(show) {
    const labelColumns = document.querySelectorAll('.label-col');
    labelColumns.forEach(col => {
        if (show) {
            col.classList.remove('hidden-col');
        } else {
            col.classList.add('hidden-col');
        }
    });
}

function optionalLabelsColIsHidden() {
    return parseInt(document.querySelector(`.button-group[data-name="optionalLabelInputs"] .toggle-button.active`).dataset.value) === 0;
}

function negateTrueJsCode(code) {
    const cleaned = code.trim().replace(/;+\s*$/, '');
    return `!( ${code} )`;
}

function onTrueJsConditionModified(boxName, index) {
    const trueInput = document.getElementById(`${boxName}_s${index}_true_code`);
    const falseInput = document.getElementById(`${boxName}_s${index}_false_code`);
    const trueValue = trueInput.value;

    let previousTrueJsCode = state.lastTrueJsCodes[`${boxName}_${index}`];
    state.lastTrueJsCodes[`${boxName}_${index}`] = trueInput.value;

    if (falseInput.value.trim().length > 0 && negateTrueJsCode(previousTrueJsCode) !== falseInput.value) {
        // the false input is not empty and was user-written, we don't override it
        return;
    }

    // the false input is either empty, or it was autogenerated
    // we set it to empty if the true input is empty, or we autogenerate it if the true input is not empty
    if (trueValue.trim().length === 0) {
        falseInput.value = '';
    } else {
        falseInput.value = negateTrueJsCode(trueValue);
    }

    onFalseJsConditionModified(boxName, index);
}

function onFalseJsConditionModified(boxName, index) {
    // we set the autogenerated class if the code is a negation of the true code, removing it if it's not
    const falseInput = document.getElementById(`${boxName}_s${index}_false_code`);

    let trueJsCode = state.lastTrueJsCodes[`${boxName}_${index}`];
    let negatedJsCode = trueJsCode == null ? null : negateTrueJsCode(state.lastTrueJsCodes[`${boxName}_${index}`]);

    if (negatedJsCode == null || falseInput.value.trim() !== negatedJsCode.trim()) {
        falseInput.classList.remove('autogenerated');
    } else {
        falseInput.classList.add('autogenerated');
    }
}

function generateCases() {
    document.getElementById('cases').innerHTML = '';
    state.cases = [];

    const statementCounts = boxNames.map(boxName => getStatementsCount(boxName));
    const totalCases = [];

    function generateCombos(depth = 0, current = []) {
        if (depth === boxNames.length) {
            // blank boxes are never all-true or all-false, they're always the "other" option
            const nonBlankBoxes = current.filter(arr => arr.length > 0);

            if (nonBlankBoxes.length === 0) {
                return;
            }

            // must have one all TRUE and one all FALSE
            const allTrue = nonBlankBoxes.some(arr => arr.every(x => x));
            const allFalse = nonBlankBoxes.some(arr => arr.every(x => !x));
            if (allTrue && allFalse) {
                totalCases.push(current);
            }
            return;
        }
        const size = statementCounts[depth];
        const max = 1 << size;
        for (let i = 0; i < max; i++) {
            const combo = [];
            for (let j = 0; j < size; j++) {
                combo.push(Boolean(i & (1 << j)));
            }
            generateCombos(depth + 1, current.concat([combo]));
        }
    }

    generateCombos();
    totalCases.forEach((combo, caseIndex) => {
        const caseDiv = document.createElement('div');
        caseDiv.className = 'case';
        caseDiv.dataset.caseNumber = caseIndex + 1;
        let effects = '<div class="effects-container">';
        boxNames.forEach((boxName, boxIndex) => {
            const count = combo[boxIndex].length;
            const part = `<b><u>${boxName} (${combo[boxIndex].map(v => v ? '<span class="effect-span effect-true">TRUE</span>' : '<span class="effect-span effect-false">FALSE</span>').join(' / ')}):</u></b><br>` +
                combo[boxIndex].map((assumedTrue, statementIndex) => {
                    const idPrefix = `${boxName}_s${statementIndex + 1}_${assumedTrue ? 'true' : 'false'}`;
                    const codeInputId = `${idPrefix}_code`;
                    const labelInputId = `${idPrefix}_label`;
                    const code = document.getElementById(codeInputId)?.value || '';
                    const label = document.getElementById(labelInputId)?.value || '';

                    let isDisplayingCode = label.trim().length === 0;
                    let displaySafeHTML = isDisplayingCode ? `<code>\`${escapeHTML(code)}\`</code>` : escapeHTML(`${label}`);

                    return `<span class="stmt" data-box-name="${boxName}" data-statement-index="${statementIndex}" data-assumed-true="${assumedTrue}">${statementIndex + 1}. ${displaySafeHTML}</span>`;
                }).join('<br>');
            effects += `<div class="effects">${part}</div>`;
        });
        effects += '</div>';
        let reasoning = '<div class="reasoning"></div>';

        caseDiv.innerHTML = `<h3>CASE ${caseIndex + 1}</h3>${effects}${reasoning}`;
        document.getElementById('cases').appendChild(caseDiv);
        state.cases.push({
            combo,
            element: caseDiv
        });
    });
}

function clearCalculations() {
    state.cases.forEach(({
        element
    }) => {
        element.classList.remove('invalid-case');
        element.classList.remove('ambiguous-case');
        element.querySelectorAll('.stmt').forEach(span => span.classList.remove('highlight-false'));
    });
}

function clearAll() {
    state.cases = [];
    document.getElementById('cases').innerHTML = '';
    boxNames.forEach(boxName => {
        // we clear ALL, the maximum
        for (let i = 0; i < maxPossibleStatements; i++) {
            for (let stateKey of ['true', 'false']) {
                const labelId = `${boxName}_s${i + 1}_${stateKey}_label`;
                const codeId = `${boxName}_s${i + 1}_${stateKey}_code`;
                const labelEl = document.getElementById(labelId);
                const codeEl = document.getElementById(codeId);
                if (labelEl) {
                    labelEl.value = '';
                }
                if (codeEl) {
                    codeEl.value = '';
                }
                codeEl.classList.remove('autogenerated');
            }
        }
    });

    document.getElementById('outcomeSummary').style.display = 'none';
    document.getElementById('outcomeText').textContent = '';
}

function isValidState(params) {
    if (typeof params !== 'object' || params === null) {
        return false;
    }

    for (const boxName of boxNames) {
        const box = params[boxName];
        if (!box || typeof box.count !== 'number' || !Array.isArray(box.statements)) {
            return false;
        }

        if (box.statements.length !== box.count) {
            return false;
        }

        for (const statement of box.statements) {
            for (const stateType of ['true', 'false']) {
                const state = statement[stateType];
                if (!state || typeof state.label !== 'string' || typeof state.code !== 'string') {
                    return false;
                }
            }
        }
    }

    return true;
}

function serializeStateToUrl() {
    const params = {};

    for (let boxName of boxNames) {
        const count = getStatementsCount(boxName);
        params[boxName] = { count, statements: [] };

        for (let i = 0; i < count; i++) {
            const statement = {};
            for (let stateType of ['true', 'false']) {
                const labelId = `${boxName}_s${i + 1}_${stateType}_label`;
                const codeId = `${boxName}_s${i + 1}_${stateType}_code`;
                const labelEl = document.getElementById(labelId);
                const codeEl = document.getElementById(codeId);
                if (labelEl && codeEl) {
                    statement[stateType] = {
                        label: labelEl.value,
                        code: codeEl.value,
                    };
                }
            }
            params[boxName].statements.push(statement);
        }
    }

    const encoded = btoa(JSON.stringify(params));
    const url = new URL(window.location);
    url.search = `data=${encoded}`;
    history.replaceState({}, '', url);
}


function loadSerializedStateFromUrl() {
    const urlParams = new URLSearchParams(window.location.search);
    const encoded = urlParams.get('data');

    if (!encoded) {
        return;
    }

    let params;
    try {
        params = JSON.parse(atob(encoded));
        if (!isValidState(params)) {
            throw new Error("Invalid structure");
        }
    } catch (e) {
        console.error("Failed to decode params from URL:", e);
        return;
    }

    for (let boxName of boxNames) {
        const boxState = params[boxName];
        if (!boxState) {
            continue;
        }

        const group = document.querySelector(`.button-group[data-name="${boxName.toLowerCase()}Count"]`);
        if (!group) {
            continue;
        }
        
        for (let toggleButton of group.querySelectorAll('.toggle-button')) {
            toggleButton.classList.toggle('active', toggleButton.dataset.value === String(boxState.count));
        }
    }

    generateInputs();

    for (let boxName of boxNames) {
        const boxState = params[boxName];
        if (!boxState) {
            continue;
        }

        for (let i = 0; i < boxState.count; i++) {
            const statement = boxState.statements[i];
            if (!statement) continue;

            for (let stateType of ['true', 'false']) {
                const data = statement[stateType];
                const labelId = `${boxName}_s${i + 1}_${stateType}_label`;
                const codeId = `${boxName}_s${i + 1}_${stateType}_code`;

                const labelEl = document.getElementById(labelId);
                const codeEl = document.getElementById(codeId);

                if (labelEl) {
                    labelEl.value = data?.label || '';
                }
                if (codeEl) {
                    codeEl.value = data?.code || '';
                }
            }
        }
    }
}

function strictContext(obj, objName) {
    return new Proxy(obj, {
        get(target, prop) {
            if (!(prop in target)) {
                throw new Error(`Tried accessing an unknown property \`${prop}\` on the object \`${objName}\`.`);
            }

            const value = target[prop];

            if (value && typeof value === 'object') {
                return strictContext(value, `${objName}.${prop}`);
            }
            return value;
        }
    });
}


function calculate() {
    clearCalculations();
    generateCases();
    
    console.log("Calculating contradictions across all cases...");

    let allValidBoxIndexes = new Set();

    let nextCaseIndex = 0;
    for (let {combo, element} of state.cases) {
        let caseIndex = nextCaseIndex++;
        console.log(`\n\n\nEvaluating Case ${caseIndex + 1}\nBlue: ${combo[0].map(x => x ? 'TRUE' : 'FALSE').join(' / ')}\nWhite: ${combo[1].map(x => x ? 'TRUE' : 'FALSE').join(' / ')}\nBlack: ${combo[2].map(x => x ? 'TRUE' : 'FALSE').join(' / ')}`);

        let contradictionSafeHTMLs = [];
        let failedStatementsSet = new Set();
        let foundValidSubcaseInds = [];
        // we go through all sub-cases
        for (let gemsInBoxInd = 0; gemsInBoxInd < boxNames.length; gemsInBoxInd++) {
            console.log(`\nCase ${caseIndex + 1}, subcase ${gemsInBoxInd + 1}`);

            const boxPropsObjects = [];
            for (let i = 0; i < boxNames.length; i++) {
                const boxName = boxNames[i];
                let boxCombo = combo[i];
                const boxProps = {
                    color: boxName.toLowerCase(),
                    oneIsTrue: boxCombo.length > 0 ? boxCombo[0] === true : false,
                    oneIsFalse: boxCombo.length > 0 ? boxCombo[0] === false : false,
                    twoIsTrue: boxCombo.length > 1 ? boxCombo[1] === true : false,
                    twoIsFalse: boxCombo.length > 1 ? boxCombo[1] === false : false,
                    threeIsTrue: boxCombo.length > 2 ? boxCombo[2] === true : false,
                    threeIsFalse: boxCombo.length > 2 ? boxCombo[2] === false : false,
                    labels: boxCombo.map((v, j) => {
                        const labelId = `${boxName}_s${j + 1}_${v ? 'true' : 'false'}_label`;
                        const label = document.getElementById(labelId)?.value || '';
                        return label;
                    }),
                    bools: boxCombo.map((v, j) => {
                        const codeId = `${boxName}_s${j + 1}_${v ? 'true' : 'false'}_code`;
                        const code = document.getElementById(codeId)?.value || '';
                        return code;
                    }),
                    isAllTrue: boxCombo.length === 0 ? false : boxCombo.every(v => v === true),
                    isAllFalse: boxCombo.length === 0 ? false : boxCombo.every(v => v === false),
                    isMixed: boxCombo.length === 0 ? false : boxCombo.some(v => v === true) && boxCombo.some(v => v === false),
                    trueCount: boxCombo.filter(v => v === true).length,
                    falseCount: boxCombo.filter(v => v === false).length,
                    isEmpty: gemsInBoxInd !== i,
                    hasGems: gemsInBoxInd === i
                }
                boxProps.isTrue = boxProps.isAllTrue;
                boxProps.isFalse = boxProps.isAllFalse;
                boxProps.allIsTrue = boxProps.isAllTrue;
                boxProps.allIsFalse = boxProps.isAllFalse;
                boxProps.hasNoGems = boxProps.isEmpty;
                boxProps.empty = boxProps.isEmpty;
                boxProps.notEmpty = boxProps.hasGems;
                boxProps.isNotEmpty = boxProps.hasGems;
                boxPropsObjects.push(boxProps);
            }
            const context = {
                trueBoxCount: boxPropsObjects.filter(box => box.isAllTrue).length,
                falseBoxCount: boxPropsObjects.filter(box => box.isAllFalse).length,
                trueStatementCount: boxPropsObjects.reduce((acc, box) => acc + box.trueCount, 0),
                falseStatementCount: boxPropsObjects.reduce((acc, box) => acc + box.falseCount, 0),
                boxWithGems: boxPropsObjects[gemsInBoxInd],
                boxesWithoutGems: boxPropsObjects.filter((_, index) => index !== gemsInBoxInd)
            }
            context.allTrueBoxCount = context.trueBoxCount;
            context.allFalseBoxCount = context.falseBoxCount;
            context.emptyBoxes = context.boxesWithoutGems;

            console.log(`Assuming ${boxNames[gemsInBoxInd]} has gems:`, boxPropsObjects);

            // now we need to evaluate each of the statements of each box
            let foundContradiction = false;
            for (let boxIndex = 0; boxIndex < boxNames.length; boxIndex++) {
                const boxName = boxNames[boxIndex];
                const statementTruthsArray = combo[boxIndex];
                for (let statementIndex = 0; statementIndex < statementTruthsArray.length; statementIndex++) {
                    const assumedTrue = statementTruthsArray[statementIndex];
                    const idPrefix = `${boxName}_s${statementIndex + 1}_${assumedTrue ? 'true' : 'false'}`;
                    const codeInputId = `${idPrefix}_code`;
                    const labelInputId = `${idPrefix}_label`;
                    const code = document.getElementById(codeInputId)?.value || '';
                    const label = document.getElementById(labelInputId)?.value || '';

                    let isDisplayingCode = label.trim().length === 0;
                    let displaySafeHTML = isDisplayingCode ? `<code>\`${escapeHTML(code)}\`</code>` : escapeHTML(`"${label}"`);

                    if (!code || code.trim() === '') {
                        // it's empty, we assume no contradiction
                        continue;
                    }

                    try {
                        const result = Jexl.evalSync(code, {
                            blue: strictContext(boxPropsObjects[0], 'blue'),
                            white: strictContext(boxPropsObjects[1], 'white'),
                            black: strictContext(boxPropsObjects[2], 'black'),
                            context: strictContext(context, 'context')
                        });

                        console.log(`${boxName} ${statementIndex + 1} [${assumedTrue ? 'TRUE' : 'FALSE'}]: ${code} => ${!!result}`);

                        if (!result) {
                            foundContradiction = true;
                            failedStatementsSet.add(`${boxName}:${statementIndex}`);
                            contradictionSafeHTMLs.push(`If gems in ${boxName.toLowerCase()}:\n${displaySafeHTML}\nThat assumption derived from ${boxName.toLowerCase()} box ${statementIndex + 1} is a CONTRADICTION`);
                            break;
                        }
                    } catch (err) {
                        alert(`Error evaluating the JS for ${boxName} statement ${statementIndex + 1}: ${err.message}`);
                        return;
                    }
                }

                if (foundContradiction) {
                    break;
                }
            }

            if (!foundContradiction) {
                foundValidSubcaseInds.push(gemsInBoxInd);
                console.log(`No contradictions in this sub-case, case ${caseIndex + 1} is valid if we assume ${boxNames[gemsInBoxInd]} has gems!`);
            } else {
                console.log(`That's a contradiction. This sub-case is no good.`);
            }
        }

        let reasoningDiv = element.querySelector('.reasoning');
        let reasoningHeading = document.createElement('h4');
        reasoningDiv.appendChild(reasoningHeading);

        if (foundValidSubcaseInds.length === 0) {
            reasoningHeading.textContent = `Invalid case. Reasoning:`;

            console.log(`Case ${caseIndex + 1} is INVALID. All sub-cases (possible gem placements) lead to contradictions.`);
            element.classList.add('invalid-case');
            element.querySelectorAll('.stmt').forEach(span => {
                const boxName = span.dataset.boxName;
                const statementIndex = span.dataset.statementIndex;
                
                if (failedStatementsSet.has(`${boxName}:${statementIndex}`)) {
                    span.classList.add('highlight-false');
                } else {
                    span.classList.remove('highlight-false');
                }
            });
                
            const ol = document.createElement('ol');
            for (let i = 0; i < contradictionSafeHTMLs.length; i++) {
                const contradictionHTML = contradictionSafeHTMLs[i];
                const li = document.createElement('li');
                li.innerHTML = contradictionHTML;
                ol.appendChild(li);
            }
            reasoningDiv.appendChild(ol);
        } else {
            for (let index of foundValidSubcaseInds) {
                allValidBoxIndexes.add(index);
            }

            let validSubcaseString;
            if (foundValidSubcaseInds.length === 1) {
                reasoningHeading.textContent = `Valid case.`;
                validSubcaseString = `Case ${caseIndex + 1} is VALID if we assume the gems are in the ${boxNames[foundValidSubcaseInds[0]].toUpperCase()} box.`;
            } else {
                element.classList.add('ambiguous-case');
                reasoningHeading.textContent = `Ambiguous case.`;
                validSubcaseString = `Case ${caseIndex + 1} is ambiguous: it's valid if the gems are in either of the following boxes: ${foundValidSubcaseInds.map(ind => boxNames[ind].toUpperCase()).join(', ')}.`;
            }

            console.log(validSubcaseString);
            const span = document.createElement('span');
            span.textContent = validSubcaseString;
            reasoningDiv.appendChild(span);
        }
    }

    if (allValidBoxIndexes.size === 0) {
        document.getElementById('outcomeSummary').classList.remove('found-answer');
        document.getElementById('outcomeSummary').classList.remove('ambiguous-answer');
        document.getElementById('outcomeSummary').classList.add('no-answer');
        document.getElementById('outcomeText').textContent = 'No valid cases found. This should be impossible, please double-check your statements to ensure the logic checks are correct.';
    } else if (allValidBoxIndexes.size === 1) {
        document.getElementById('outcomeSummary').classList.remove('no-answer');
        document.getElementById('outcomeSummary').classList.remove('ambiguous-answer');
        document.getElementById('outcomeSummary').classList.add('found-answer');
        document.getElementById('outcomeText').textContent = `Based on the statements, the only possibility is that the gems are in the ${boxNames[Array.from(allValidBoxIndexes)[0]].toUpperCase()} box!`;
    } else {
        document.getElementById('outcomeSummary').classList.remove('no-answer');
        document.getElementById('outcomeSummary').classList.remove('found-answer');
        document.getElementById('outcomeSummary').classList.add('ambiguous-answer');
        document.getElementById('outcomeText').textContent = `The result is ambiguous, please either double-check that you have translated each of the logical statements to valid JS code, or alternatively check the cases manually to weed out some contradictions manually.\n\nBased on the statements, the gems could be in any of the following boxes: ${Array.from(allValidBoxIndexes).map(ind => boxNames[ind].toUpperCase()).join(', ')}.`;
    }

    document.getElementById('outcomeSummary').style.display = 'block';

    serializeStateToUrl();
}

function openHelpModal() {
    document.getElementById('helpModal').style.display = 'flex';
}

function closeHelpModal() {
    document.getElementById('helpModal').style.display = 'none';
}

document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.button-group').forEach(group => {
        group.addEventListener('click', (e) => {
            if (e.target.classList.contains('toggle-button')) {
                group.querySelectorAll('.toggle-button').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
            }

            // we also regenerate the inputs when the toggle buttons are clicked
            generateInputs();
        });
    });

    document.querySelectorAll('.show-hide-label-btn').forEach(button => {
        button.addEventListener('click', () => {
            const shouldShow = button.dataset.value === "1";
            toggleOptionalLabelInputs(shouldShow);
        });
    });

    generateInputs();
    loadSerializedStateFromUrl();
});
</script>
</html>
