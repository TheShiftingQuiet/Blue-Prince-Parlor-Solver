<!DOCTYPE html>
<html lang="en">

<head>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
<meta name="google-site-verification" content="yWIwJYlQ8faIP56kh9RW-Idj4AeMLwZTncl3cif3tmY" />
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Parlor Solver: a tool to help you solve the parlor puzzles from the game Blue Prince using rule-based boolean logic.">
<script src="jexl.browser.js"></script>
<title>Parlor Solver | Blue Prince</title>
<style>
    body {
        font-family: sans-serif;
        margin: 0;
        padding: 20px;
    }

    .box-toggle-groups {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        width: 100%;
        margin: 10px 0;
        gap: 20px;
    }
    input {
        width: 100%;
        margin: 2px 0;
    }
    button {
        margin-right: 5px;
    }
    .effects-container {
        display: flex;
        flex-wrap: wrap;
        flex-direction: row;
        margin-top: 10px;
    }
    .effects {
        margin-top: 10px;
        margin-right: 50px;
    }
    .toggle-group {
        display: flex;
        align-items: center;
        width: 220px;
        justify-content: flex-end;
    }

    .toggle-label {
        font-weight: bold;
        align-self: center;
    }

    .button-group {
        min-width: 118px;
        margin-left: 10px;
        margin-right: 40px;
        display: flex;
        flex-direction: column;
    }

    .button-group.horizontal {
        flex-direction: row;
    }

    button {
        padding: 6px 14px;
        margin-right: 6px;
        border: 1px solid #888;
        background-color: #f0f0f0;
        cursor: pointer;
        border-radius: 4px;
        font-size: 14px;
        user-select: none;
        transition: background-color 0.2s, color 0.2s;
    }

    button:hover {
        background-color: #e0e0e0;
    }

    .toggle-button {
        margin-right: 6px;
    }

    .toggle-button.active {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
    }

    .statement-block {
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 10px;
        margin-top: 12px;
        background-color: #fafafa;
        color: black;
    }

    .statement-block h4 {
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 16px;
        border-bottom: 1px solid #ddd;
        padding-bottom: 4px;
    }

    .statement-grid {
        display: grid;
        grid-template-columns: 1fr 2fr;
        gap: 6px 12px;
        align-items: center;
    }

    .statement-grid label {
        font-weight: 500;
    }

    .statement-grid input {
        width: 100%;
        font-family: monospace;
        font-size: 14px;
        padding: 4px;
        box-sizing: border-box;
    }

    .statement-compact-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 6px;
        font-size: 14px;
    }

    .statement-compact-table th,
    .statement-compact-table td {
        padding: 4px 6px;
        border: 1px solid #ddd;
        vertical-align: middle;
    }

    .statement-compact-table input {
        width: 100%;
        font-family: monospace;
        font-size: 14px;
        box-sizing: border-box;
    }

    .controls {
        margin-top: 20px;
        display: flex;
        justify-content: center;
        width: 100%;
    }

    .other-settings-optional-labels {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 15px 0;
    }

    .optional-label-inputs {
        width: 100%;
    }

    .optional-label-inputs .toggle-button {
        width: 50%;
        max-width: 200px;
    }

    .optional-label-inputs.button-group {
        justify-content: center;
        margin-top: 5px;
    }

    #inputArea {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
    }

    .box {
        border: 1px solid #aaa;
        padding: 10px;
        flex: 1 1 300px;
        min-width: 300px;
        max-width: 100%;
        box-sizing: border-box;        
    }

    .box:nth-child(1) {
        background-color: #9dc9ff;
    }
    .box:nth-child(2) {
        background-color: #ffffff;
    }
    .box:nth-child(3) {
        background-color: #2e2e2e;
        color: white;
    }

    .case {
        margin: 10px 0;
        border: 2px solid #333;
        padding: 10px;
        background-color: #ccffcc
    }

    #outcomeSummary {
        margin: 10px 0;
        border: 2px solid #333;
        padding: 10px;
    }

    #outcomeSummary.found-answer {
        background-color: #ccffcc;
    }

    #outcomeSummary.no-answer {
        background-color: #ffcccc;
    }

    #outcomeSummary.ambiguous-answer {
        background-color: #d5b1de;
    }

    #outcomeText {
        white-space-collapse: preserve;
    }

    .case.invalid-case {
        background-color: #ffcccc;
    }

    .case.ambiguous-case {
        background-color: #d5b1de;
    }
    
    .highlight-false {
        background-color: yellow;
    }

    .case .effect-false {
        color: red;
    }

    .case .effect-true {
        color: green;
    }

    .reasoning li {
        white-space-collapse: preserve;
        margin-bottom: 10px;
    }

    #helpModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        z-index: 1000;
        padding: 50px;
        box-sizing: border-box;
        justify-content: center;
        align-items: center;
    }

    #helpModalInner {
        background: white;
        border-radius: 8px;
        width: 100%;
        height: 100%;
        max-width: 100%;
        max-height: 100%;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        box-sizing: border-box;
    }

    #helpModalHeader {
        flex: 0 0 auto;
        padding: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: white;
        z-index: 1;
    }

    #helpModalContent {
        flex: 1 1 auto;
        overflow-y: auto;
        padding: 0 20px 20px 20px;
        box-sizing: border-box;
    }

    .autogenerated {
        background-color: #edffef;
        border: 1px solid #2390f2;
        color: #7b7b7b;
        border-style: dashed;
    }

    .label-col.hidden-col {
        display: none;
    }
</style>
</head>

<body>
    <div class="setup-controls">
        <div class="box-toggle-groups">
            <div class="toggle-group">
                <div><label class="toggle-label">Blue:</label></div>
                <div class="button-group" data-name="blueCount">
                    <button class="toggle-button" data-value="0">Blank box</button>
                    <button class="toggle-button" data-value="1">1 statement</button>
                    <button class="toggle-button active" data-value="2">2 statements</button>
                    <button class="toggle-button" data-value="3">3 statements</button>
                </div>
            </div>
            <div class="toggle-group">
                <div><label class="toggle-label">White:</label></div>
                <div class="button-group" data-name="whiteCount">
                    <button class="toggle-button" data-value="0">Blank box</button>
                    <button class="toggle-button" data-value="1">1 statement</button>
                    <button class="toggle-button active" data-value="2">2 statements</button>
                    <button class="toggle-button" data-value="3">3 statements</button>
                </div>
            </div>
            <div class="toggle-group">
                <div><label class="toggle-label">Black:</label></div>
                <div class="button-group" data-name="blackCount">
                    <button class="toggle-button" data-value="0">Blank box</button>
                    <button class="toggle-button" data-value="1">1 statement</button>
                    <button class="toggle-button active" data-value="2">2 statements</button>
                    <button class="toggle-button" data-value="3">3 statements</button>
                </div>
            </div>
        </div>
        <div class="other-settings">
            <div class="other-settings-optional-labels">
                <div>Show optional label inputs? They are just for your own reference.</div>
                <div class="button-group horizontal optional-label-inputs" data-name="optionalLabelInputs">
                    <button class="toggle-button active show-hide-label-btn" data-value="0">Hide</button>
                    <button class="toggle-button show-hide-label-btn" data-value="1">Show</button>
                </div>
            </div>
        </div>
    </div>
    <div id="inputArea"></div>
    <div class="controls">
        <button onclick="calculate()">Calculate</button>
        <button onclick="clearCalculations()">Clear calculations</button>
        <button onclick="clearAll()">Clear all</button>
        <button onclick="openHelpModal()">Help</button>
    </div>
    <div id="outcomeSummary" style="display: none;">
        <h3>Outcome</h3>
        <p id="outcomeText"></p>
    </div>
    <div id="cases"></div>

    <div id="helpModal">
        <div id="helpModalInner">
            <div id="helpModalHeader">
                <h2>Instructions</h2>
                <button id="closeHelpModalBtn" onclick="closeHelpModal()" style="margin-top: 20px;">Close</button>        
            </div>
            <div id="helpModalContent">
                <p>You know the rules for the parlor already from Blue Prince.</p>
                <p>You need to choose the number of statements you have for each of the three boxes, as well as filling out the statements:</p>
                <ul>
                    <li><strong>Label (optional)</strong>: the label. For the True case - this can be the statement on the box, verbatim. For the False case - this would be the negation: "(the statement) is not true". In most cases, you can word the negation more clearly.</li>
                    <li><strong>Condition (JS/JEXL)</strong>: A javascript expression that evaluates to a truthy value if the statement is logically consistent with the assumption, or a falsy value if it contradicts it. Typically, the False version for this is just the same as the True variant but negated, but sometimes you might want to write 'false' if the statement contradicts itself (like "every statement with the word empty is false" - that statement cannot be true by definition).</li>
                </ul>

                <p>The script go through each possible combination of which statements are true/false, e.g. blue statement 1 is True, blue statement 2 is True, white statement 1 is False, white statement 2 is True, black has one statement and it's False.</p>
                <p>For each combination (case), it will consider 3 possibilities: gems are in the blue box, gems are in the white box, and gems are in the black box.</p>
                <p>For each of those possibilities, it will evaluate the JS conditions for the assumption and if any of the possibilities has all of the JS conditions returning true - that's a valid case. Else, it shows the contradiction.</p>            
                <p>Your JS condition will have access to the following objects (and each will have a different value when considering each possibility) - <code>blue</code>, <code>white</code>, <code>black</code>, each object with:</li>
                </ul>
                <pre><code>{
        "color": "blue" or "white" or "black",
        "oneIsTrue": true if blue 1 statement is assumed true in this case, false otherwise,
        "oneIsFalse": true if blue 1 statement is assumed false in this case, false otherwise,
        "twoIsTrue": true if blue 2 statement is assumed true in this case, false otherwise,
        "twoIsFalse": true if blue 2 statement is assumed false in this case, false otherwise,
        "threeIsTrue": true if blue 3 statement is assumed true in this case, false otherwise,
        "threeIsFalse": true if blue 3 statement is assumed false in this case, false otherwise,
        "labels": array of strings, each representing the label of the statement in this box (labels[0] = blue 1 label, labels[1] = blue 2 statement, etc.)
        "bools": array of booleans, each representing the truthiness of the statement in this box (bools[0] = blue.oneIsTrue, bools[1] = blue.twoIsTrue, etc.)
        "isAllTrue" or "isTrue": true if all of the statements in this box are assumed true in this case, false otherwise
        "isAllFalse" or "isFalse": true if all of the statements in this box are assumed false in this case, false otherwise
        "isMixed": true if this box has at least one true and at least one false statement (so it's neither an all-true nor all-false box)
        "trueCount": number of statements that are assumed true in this case
        "falseCount": number of statements that are assumed false in this case
        "isEmpty" or "empty" or "hasNoGems": true if this sub-case assumes it's empty
        "hasGems" or "notEmpty" or "isNotEmpty": true if this sub-case assumes it has gems
    }</code></pre>
                <p>You will also have access to the object "context" with the following properties:</p>
                <pre><code>{
        "trueBoxCount" or "allTrueBoxCount": number of boxes that are assumed to have only true statements in this case
        "falseBoxCount" or "allFalseBoxCount": number of boxes that are assumed to have only false statements in this case
        "trueStatementCount": number of statements that are assumed true in this case across all boxes
        "falseStatementCount": number of statements that are assumed false in this case across all boxes
        "boxWithGems": a reference to the box object that is assumed to have gems in this sub-case
        "boxesWithoutGems" or "emptyBoxes": an array of references to the box objects that are assumed to be empty in this sub-case
    }</code></pre>
                <h3>Example:</h3>
                <p>If you're doing the TRUE js condition for the statement "the white box is empty", then use the following JS condition:</p>
                <code>white.isEmpty</code><br>
                <p>If you're doing the FALSE js condition for the statement "every statement with the word "empty" is false", the negation of which would be "at least one statement with the word "empty" is true", and assuming the statements that contain the word "empty' are blue 1, white 1, white 2 and black 1, then use the following JS condition:</p>
                <code>blue.oneIsTrue || white.oneIsTrue || white.twoIsTrue || black.oneIsTrue
            </div>
        </div>
    </div>

</body>

<script>
const maxPossibleStatements = 3;
const boxNames = ['Blue', 'White', 'Black'];
// just a sanity check - we make sure none of the box names include any HTML characters, since we treat this as safe
const unsafeChars = ['<', '>', '&', '"', "'", '`'];
boxNames.forEach(boxName => {
    if (unsafeChars.some(char => boxName.includes(char))) {
        let err = `Box name "${boxName}" contains unsafe characters.`;
        console.error(err);
        alert(err);
        throw new Error(err);
    }
});

function escapeHTML(str) {
    return str.replace(/[&<>"']/g, match => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
    }[match]));
}

const state = {
    inputs: {},
    cases: [],
    // we keep track of the last known JS codes for each box and statement for reasons you can find in the onTrueJsConditionBlur function
    lastTrueJsCodes: {},
};

function getStatementsCount(boxName) {
    return parseInt(document.querySelector(`.button-group[data-name="${boxName.toLowerCase()}Count"] .toggle-button.active`).dataset.value);
}


function generateInputs() {
    const inputArea = document.getElementById('inputArea');

    boxNames.forEach(boxName => {
        const count = getStatementsCount(boxName);

        let boxDiv = document.querySelector(`#box_${boxName}`);
        if (!boxDiv) {
            boxDiv = document.createElement('div');
            boxDiv.classList.add('box');
            boxDiv.id = `box_${boxName}`;
            boxDiv.innerHTML = `<h3>${boxName}</h3>`;
            for (let i = 0; i < maxPossibleStatements; i++) {
                const statementBlock = document.createElement('div');
                statementBlock.classList.add('statement-block');
                statementBlock.id = `${boxName}_statement_${i + 1}`;
                let labelClasses = `label-col${optionalLabelsColIsHidden() ? ' hidden-col' : ''}`;
                statementBlock.innerHTML = `
                    <h4>Statement ${i + 1}</h4>
                    <table class="statement-compact-table">
                        <thead>
                            <tr>
                                <th></th>
                                <th class="${labelClasses}">Label (optional)</th>
                                <th>Condition (JS/JEXL)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>If TRUE</strong></td>
                                <td class="${labelClasses}"><input type="text" id="${boxName}_s${i + 1}_true_label" /></td>
                                <td><input type="text" id="${boxName}_s${i + 1}_true_code" oninput="onTrueJsConditionModified('${boxName}', ${i + 1})" /></td>
                            </tr>
                            <tr>
                                <td><strong>If FALSE</strong></td>
                                <td class="${labelClasses}"><input type="text" id="${boxName}_s${i + 1}_false_label" /></td>
                                <td><input type="text" id="${boxName}_s${i + 1}_false_code" oninput="onFalseJsConditionModified('${boxName}', ${i + 1})" /></td>
                            </tr>
                        </tbody>
                    </table>
                `;
                boxDiv.appendChild(statementBlock);
            }
            inputArea.appendChild(boxDiv);
        }

        for (let i = 0; i < maxPossibleStatements; i++) {
            const block = document.getElementById(`${boxName}_statement_${i + 1}`);
            block.style.display = (i < count) ? '' : 'none';
        }
    });
}

function toggleOptionalLabelInputs(show) {
    const labelColumns = document.querySelectorAll('.label-col');
    labelColumns.forEach(col => {
        if (show) {
            col.classList.remove('hidden-col');
        } else {
            col.classList.add('hidden-col');
        }
    });
}

function optionalLabelsColIsHidden() {
    return parseInt(document.querySelector(`.button-group[data-name="optionalLabelInputs"] .toggle-button.active`).dataset.value) === 0;
}

function negateTrueJsCode(code) {
    const cleaned = code.trim().replace(/;+\s*$/, '');
    return `!( ${code} )`;
}

function onTrueJsConditionModified(boxName, index) {
    const trueInput = document.getElementById(`${boxName}_s${index}_true_code`);
    const falseInput = document.getElementById(`${boxName}_s${index}_false_code`);
    const trueValue = trueInput.value;

    let previousTrueJsCode = state.lastTrueJsCodes[`${boxName}_${index}`];
    state.lastTrueJsCodes[`${boxName}_${index}`] = trueInput.value;

    if (falseInput.value.trim().length > 0 && negateTrueJsCode(previousTrueJsCode) !== falseInput.value) {
        // the false input is not empty and was user-written, we don't override it
        return;
    }

    // the false input is either empty, or it was autogenerated
    // we set it to empty if the true input is empty, or we autogenerate it if the true input is not empty
    if (trueValue.trim().length === 0) {
        falseInput.value = '';
    } else {
        falseInput.value = negateTrueJsCode(trueValue);
    }

    onFalseJsConditionModified(boxName, index);
}

function onFalseJsConditionModified(boxName, index) {
    // we set the autogenerated class if the code is a negation of the true code, removing it if it's not
    const falseInput = document.getElementById(`${boxName}_s${index}_false_code`);

    let trueJsCode = state.lastTrueJsCodes[`${boxName}_${index}`];
    let negatedJsCode = trueJsCode == null ? null : negateTrueJsCode(state.lastTrueJsCodes[`${boxName}_${index}`]);

    if (negatedJsCode == null || falseInput.value.trim() !== negatedJsCode.trim()) {
        falseInput.classList.remove('autogenerated');
    } else {
        falseInput.classList.add('autogenerated');
    }
}

function generateCases() {
    document.getElementById('cases').innerHTML = '';
    state.cases = [];

    const statementCounts = boxNames.map(boxName => getStatementsCount(boxName));
    const totalCases = [];

    function generateCombos(depth = 0, current = []) {
        if (depth === boxNames.length) {
            // blank boxes are never all-true or all-false, they're always the "other" option
            const nonBlankBoxes = current.filter(arr => arr.length > 0);

            if (nonBlankBoxes.length === 0) {
                return;
            }

            // must have one all TRUE and one all FALSE
            const allTrue = nonBlankBoxes.some(arr => arr.every(x => x));
            const allFalse = nonBlankBoxes.some(arr => arr.every(x => !x));
            if (allTrue && allFalse) {
                totalCases.push(current);
            }
            return;
        }
        const size = statementCounts[depth];
        const max = 1 << size;
        for (let i = 0; i < max; i++) {
            const combo = [];
            for (let j = 0; j < size; j++) {
                combo.push(Boolean(i & (1 << j)));
            }
            generateCombos(depth + 1, current.concat([combo]));
        }
    }

    generateCombos();
    totalCases.forEach((combo, caseIndex) => {
        const caseDiv = document.createElement('div');
        caseDiv.className = 'case';
        caseDiv.dataset.caseNumber = caseIndex + 1;
        let effects = '<div class="effects-container">';
        boxNames.forEach((boxName, boxIndex) => {
            const count = combo[boxIndex].length;
            const part = `<b><u>${boxName} (${combo[boxIndex].map(v => v ? '<span class="effect-span effect-true">TRUE</span>' : '<span class="effect-span effect-false">FALSE</span>').join(' / ')}):</u></b><br>` +
                combo[boxIndex].map((assumedTrue, statementIndex) => {
                    const idPrefix = `${boxName}_s${statementIndex + 1}_${assumedTrue ? 'true' : 'false'}`;
                    const codeInputId = `${idPrefix}_code`;
                    const labelInputId = `${idPrefix}_label`;
                    const code = document.getElementById(codeInputId)?.value || '';
                    const label = document.getElementById(labelInputId)?.value || '';

                    let isDisplayingCode = label.trim().length === 0;
                    let displaySafeHTML = isDisplayingCode ? `<code>\`${escapeHTML(code)}\`</code>` : escapeHTML(`${label}`);

                    return `<span class="stmt" data-box-name="${boxName}" data-statement-index="${statementIndex}" data-assumed-true="${assumedTrue}">${statementIndex + 1}. ${displaySafeHTML}</span>`;
                }).join('<br>');
            effects += `<div class="effects">${part}</div>`;
        });
        effects += '</div>';
        let reasoning = '<div class="reasoning"></div>';

        caseDiv.innerHTML = `<h3>CASE ${caseIndex + 1}</h3>${effects}${reasoning}`;
        document.getElementById('cases').appendChild(caseDiv);
        state.cases.push({
            combo,
            element: caseDiv
        });
    });
}

function clearCalculations() {
    state.cases.forEach(({
        element
    }) => {
        element.classList.remove('invalid-case');
        element.classList.remove('ambiguous-case');
        element.querySelectorAll('.stmt').forEach(span => span.classList.remove('highlight-false'));
    });
}

function clearAll() {
    state.cases = [];
    document.getElementById('cases').innerHTML = '';
    boxNames.forEach(boxName => {
        // we clear ALL, the maximum
        for (let i = 0; i < maxPossibleStatements; i++) {
            for (let stateKey of ['true', 'false']) {
                const labelId = `${boxName}_s${i + 1}_${stateKey}_label`;
                const codeId = `${boxName}_s${i + 1}_${stateKey}_code`;
                const labelEl = document.getElementById(labelId);
                const codeEl = document.getElementById(codeId);
                if (labelEl) {
                    labelEl.value = '';
                }
                if (codeEl) {
                    codeEl.value = '';
                }
            }
        }
    });

    document.getElementById('outcomeSummary').style.display = 'none';
    document.getElementById('outcomeText').textContent = '';
}

function serializeStateToUrl() {
    const params = new URLSearchParams();

    for (let boxName of boxNames) {
        params.set(boxName.toLowerCase() + 'Count', getStatementsCount(boxName));
    
        const count = getStatementsCount(boxName);
        for (let i = 0; i < count; i++) {
            for (let state of ['true', 'false']) {
                const labelId = `${boxName}_s${i + 1}_${state}_label`;
                const codeId = `${boxName}_s${i + 1}_${state}_code`;
                const labelEl = document.getElementById(labelId);
                const codeEl = document.getElementById(codeId);
                if (labelEl) {
                    params.set(labelId, labelEl.value);
                }
                if (codeEl) {
                    params.set(codeId, codeEl.value);
                }
            }
        }
    }

    const url = new URL(window.location);
    url.search = params.toString();
    history.replaceState({}, '', url);
}


function loadSerializedStateFromUrl() {
    const params = new URLSearchParams(window.location.search);

    for (let boxName of boxNames) {
        const countParam = params.get(boxName.toLowerCase() + 'Count');
        if (!countParam) {
            continue;
        }
            
        const group = document.querySelector(`.button-group[data-name="${boxName.toLowerCase()}Count"]`);
        if (!group) {
            continue;
        }

        let anyButton = false;
        for (let toggleButton of group.querySelectorAll('.toggle-button')) {
            toggleButton.classList.toggle('active', toggleButton.dataset.value === countParam);
            anyButton = anyButton || toggleButton.dataset.value === countParam;
        };

        if (!anyButton) {
            // invalid url param, we set it to the default
            group.querySelector('.toggle-button[data-value="2"]')?.classList.add('active');
        }
    }

    generateInputs();

    for (let boxName of boxNames) {
        params.set(boxName.toLowerCase() + 'Count', getStatementsCount(boxName));
    
        const count = getStatementsCount(boxName);
        for (let i = 0; i < count; i++) {
            for (let state of ['true', 'false']) {
                const labelId = `${boxName}_s${i + 1}_${state}_label`;
                const codeId = `${boxName}_s${i + 1}_${state}_code`;
                const labelEl = document.getElementById(labelId);
                const codeEl = document.getElementById(codeId);
                if (labelEl) {
                    labelEl.value = params.get(labelId) || '';
                }
                if (codeEl) {
                    codeEl.value = params.get(codeId) || '';
                }
            }
        }
    }

    setTimeout(() => {
        for (const [key, value] of params.entries()) {
            const el = document.getElementById(key);
            if (el) {
                el.value = value;
            }
        }
    }, 0);
}

function strictContext(obj, objName) {
    return new Proxy(obj, {
        get(target, prop) {
            if (!(prop in target)) {
                throw new Error(`Tried accessing an unknown property \`${prop}\` on the object \`${objName}\`.`);
            }

            const value = target[prop];

            if (value && typeof value === 'object') {
                return strictContext(value, `${objName}.${prop}`);
            }
            return value;
        }
    });
}


function calculate() {
    clearCalculations();
    generateCases();
    
    console.log("Calculating contradictions across all cases...");

    let allValidBoxIndexes = new Set();

    let nextCaseIndex = 0;
    for (let {combo, element} of state.cases) {
        let caseIndex = nextCaseIndex++;
        console.log(`\n\n\nEvaluating Case ${caseIndex + 1}\nBlue: ${combo[0].map(x => x ? 'TRUE' : 'FALSE').join(' / ')}\nWhite: ${combo[1].map(x => x ? 'TRUE' : 'FALSE').join(' / ')}\nBlack: ${combo[2].map(x => x ? 'TRUE' : 'FALSE').join(' / ')}`);

        let contradictionSafeHTMLs = [];
        let failedStatementsSet = new Set();
        let foundValidSubcaseInds = [];
        // we go through all sub-cases
        for (let gemsInBoxInd = 0; gemsInBoxInd < boxNames.length; gemsInBoxInd++) {
            console.log(`\nCase ${caseIndex + 1}, subcase ${gemsInBoxInd + 1}`);

            const boxPropsObjects = [];
            for (let i = 0; i < boxNames.length; i++) {
                const boxName = boxNames[i];
                let boxCombo = combo[i];
                const boxProps = {
                    color: boxName.toLowerCase(),
                    oneIsTrue: boxCombo.length > 0 ? boxCombo[0] === true : false,
                    oneIsFalse: boxCombo.length > 0 ? boxCombo[0] === false : false,
                    twoIsTrue: boxCombo.length > 1 ? boxCombo[1] === true : false,
                    twoIsFalse: boxCombo.length > 1 ? boxCombo[1] === false : false,
                    threeIsTrue: boxCombo.length > 2 ? boxCombo[2] === true : false,
                    threeIsFalse: boxCombo.length > 2 ? boxCombo[2] === false : false,
                    labels: boxCombo.map((v, j) => {
                        const labelId = `${boxName}_s${j + 1}_${v ? 'true' : 'false'}_label`;
                        const label = document.getElementById(labelId)?.value || '';
                        return label;
                    }),
                    bools: boxCombo.map((v, j) => {
                        const codeId = `${boxName}_s${j + 1}_${v ? 'true' : 'false'}_code`;
                        const code = document.getElementById(codeId)?.value || '';
                        return code;
                    }),
                    isAllTrue: boxCombo.length === 0 ? false : boxCombo.every(v => v === true),
                    isAllFalse: boxCombo.length === 0 ? false : boxCombo.every(v => v === false),
                    isMixed: boxCombo.length === 0 ? false : boxCombo.some(v => v === true) && boxCombo.some(v => v === false),
                    trueCount: boxCombo.filter(v => v === true).length,
                    falseCount: boxCombo.filter(v => v === false).length,
                    isEmpty: gemsInBoxInd !== i,
                    hasGems: gemsInBoxInd === i
                }
                boxProps.isTrue = boxProps.isAllTrue;
                boxProps.isFalse = boxProps.isAllFalse;
                boxProps.hasNoGems = boxProps.isEmpty;
                boxProps.empty = boxProps.isEmpty;
                boxProps.notEmpty = boxProps.hasGems;
                boxProps.isNotEmpty = boxProps.hasGems;
                boxPropsObjects.push(boxProps);
            }
            const context = {
                trueBoxCount: boxPropsObjects.filter(box => box.isAllTrue).length,
                falseBoxCount: boxPropsObjects.filter(box => box.isAllFalse).length,
                trueStatementCount: boxPropsObjects.reduce((acc, box) => acc + box.trueCount, 0),
                falseStatementCount: boxPropsObjects.reduce((acc, box) => acc + box.falseCount, 0),
                boxWithGems: boxPropsObjects[gemsInBoxInd],
                boxesWithoutGems: boxPropsObjects.filter((_, index) => index !== gemsInBoxInd)
            }
            context.allTrueBoxCount = context.trueBoxCount;
            context.allFalseBoxCount = context.falseBoxCount;
            context.emptyBoxes = context.boxesWithoutGems;

            console.log(`Assuming ${boxNames[gemsInBoxInd]} has gems:`, boxPropsObjects);

            // now we need to evaluate each of the statements of each box
            let foundContradiction = false;
            for (let boxIndex = 0; boxIndex < boxNames.length; boxIndex++) {
                const boxName = boxNames[boxIndex];
                const statementTruthsArray = combo[boxIndex];
                for (let statementIndex = 0; statementIndex < statementTruthsArray.length; statementIndex++) {
                    const assumedTrue = statementTruthsArray[statementIndex];
                    const idPrefix = `${boxName}_s${statementIndex + 1}_${assumedTrue ? 'true' : 'false'}`;
                    const codeInputId = `${idPrefix}_code`;
                    const labelInputId = `${idPrefix}_label`;
                    const code = document.getElementById(codeInputId)?.value || '';
                    const label = document.getElementById(labelInputId)?.value || '';

                    let isDisplayingCode = label.trim().length === 0;
                    let displaySafeHTML = isDisplayingCode ? `<code>\`${escapeHTML(code)}\`</code>` : escapeHTML(`"${label}"`);

                    if (!code || code.trim() === '') {
                        // it's empty, we assume no contradiction
                        continue;
                    }

                    try {
                        const result = Jexl.evalSync(code, {
                            blue: strictContext(boxPropsObjects[0], 'blue'),
                            white: strictContext(boxPropsObjects[1], 'white'),
                            black: strictContext(boxPropsObjects[2], 'black'),
                            context: strictContext(context, 'context')
                        });

                        console.log(`${boxName} ${statementIndex + 1} [${assumedTrue ? 'TRUE' : 'FALSE'}]: ${code} => ${!!result}`);

                        if (!result) {
                            foundContradiction = true;
                            failedStatementsSet.add(`${boxName}:${statementIndex}`);
                            contradictionSafeHTMLs.push(`If gems in ${boxName.toLowerCase()}:\n${displaySafeHTML}\nThat assumption derived from ${boxName.toLowerCase()} box ${statementIndex + 1} is a CONTRADICTION`);
                            break;
                        }
                    } catch (err) {
                        alert(`Error evaluating the JS for ${boxName} statement ${statementIndex + 1}: ${err.message}`);
                        return;
                    }
                }

                if (foundContradiction) {
                    break;
                }
            }

            if (!foundContradiction) {
                foundValidSubcaseInds.push(gemsInBoxInd);
                console.log(`No contradictions in this sub-case, case ${caseIndex + 1} is valid if we assume ${boxNames[gemsInBoxInd]} has gems!`);
            } else {
                console.log(`That's a contradiction. This sub-case is no good.`);
            }
        }

        let reasoningDiv = element.querySelector('.reasoning');
        let reasoningHeading = document.createElement('h4');
        reasoningDiv.appendChild(reasoningHeading);

        if (foundValidSubcaseInds.length === 0) {
            reasoningHeading.textContent = `Invalid case. Reasoning:`;

            console.log(`Case ${caseIndex + 1} is INVALID. All sub-cases (possible gem placements) lead to contradictions.`);
            element.classList.add('invalid-case');
            element.querySelectorAll('.stmt').forEach(span => {
                const boxName = span.dataset.boxName;
                const statementIndex = span.dataset.statementIndex;
                
                if (failedStatementsSet.has(`${boxName}:${statementIndex}`)) {
                    span.classList.add('highlight-false');
                } else {
                    span.classList.remove('highlight-false');
                }
            });
                
            const ol = document.createElement('ol');
            for (let i = 0; i < contradictionSafeHTMLs.length; i++) {
                const contradictionHTML = contradictionSafeHTMLs[i];
                const li = document.createElement('li');
                li.innerHTML = contradictionHTML;
                ol.appendChild(li);
            }
            reasoningDiv.appendChild(ol);
        } else {
            for (let index of foundValidSubcaseInds) {
                allValidBoxIndexes.add(index);
            }

            let validSubcaseString;
            if (foundValidSubcaseInds.length === 1) {
                reasoningHeading.textContent = `Valid case.`;
                validSubcaseString = `Case ${caseIndex + 1} is VALID if we assume the gems are in the ${boxNames[foundValidSubcaseInds[0]].toUpperCase()} box.`;
            } else {
                element.classList.add('ambiguous-case');
                reasoningHeading.textContent = `Ambiguous case.`;
                validSubcaseString = `Case ${caseIndex + 1} is ambiguous: it's valid if the gems are in either of the following boxes: ${foundValidSubcaseInds.map(ind => boxNames[ind].toUpperCase()).join(', ')}.`;
            }

            console.log(validSubcaseString);
            const span = document.createElement('span');
            span.textContent = validSubcaseString;
            reasoningDiv.appendChild(span);
        }
    }

    if (allValidBoxIndexes.size === 0) {
        document.getElementById('outcomeSummary').classList.remove('found-answer');
        document.getElementById('outcomeSummary').classList.remove('ambiguous-answer');
        document.getElementById('outcomeSummary').classList.add('no-answer');
        document.getElementById('outcomeText').textContent = 'No valid cases found. This should be impossible, please double-check your statements to ensure the logic checks are correct.';
    } else if (allValidBoxIndexes.size === 1) {
        document.getElementById('outcomeSummary').classList.remove('no-answer');
        document.getElementById('outcomeSummary').classList.remove('ambiguous-answer');
        document.getElementById('outcomeSummary').classList.add('found-answer');
        document.getElementById('outcomeText').textContent = `Based on the statements, the only possibility is that the gems are in the ${boxNames[Array.from(allValidBoxIndexes)[0]].toUpperCase()} box!`;
    } else {
        document.getElementById('outcomeSummary').classList.remove('no-answer');
        document.getElementById('outcomeSummary').classList.remove('found-answer');
        document.getElementById('outcomeSummary').classList.add('ambiguous-answer');
        document.getElementById('outcomeText').textContent = `The result is ambiguous, please either double-check that you have translated each of the logical statements to valid JS code, or alternatively check the cases manually to weed out some contradictions manually.\n\nBased on the statements, the gems could be in any of the following boxes: ${Array.from(allValidBoxIndexes).map(ind => boxNames[ind].toUpperCase()).join(', ')}.`;
    }

    document.getElementById('outcomeSummary').style.display = 'block';

    serializeStateToUrl();
}

function openHelpModal() {
    document.getElementById('helpModal').style.display = 'flex';
}

function closeHelpModal() {
    document.getElementById('helpModal').style.display = 'none';
}

document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.button-group').forEach(group => {
        group.addEventListener('click', (e) => {
            if (e.target.classList.contains('toggle-button')) {
                group.querySelectorAll('.toggle-button').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
            }

            // we also regenerate the inputs when the toggle buttons are clicked
            generateInputs();
        });
    });

    document.querySelectorAll('.show-hide-label-btn').forEach(button => {
        button.addEventListener('click', () => {
            const shouldShow = button.dataset.value === "1";
            toggleOptionalLabelInputs(shouldShow);
        });
    });

    generateInputs();
    loadSerializedStateFromUrl();
});
</script>
</html>
