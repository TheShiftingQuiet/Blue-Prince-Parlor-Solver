<!DOCTYPE html>
<html lang="en">

<head>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
<meta name="google-site-verification" content="yWIwJYlQ8faIP56kh9RW-Idj4AeMLwZTncl3cif3tmY" />
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Parlor Solver: a tool to help you solve the parlor puzzles from the game Blue Prince using rule-based boolean logic.">

<meta property="og:title" content="Parlor Puzzle Solver | Blue Prince" />
<meta property="og:description" content="Solve the parlor logic puzzles from Blue Prince using this interactive, rule-based boolean logic deduction tool." />
<meta property="og:url" content="https://theshiftingquiet.github.io/Blue-Prince-Parlor-Solver/" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://theshiftingquiet.github.io/Blue-Prince-Parlor-Solver/preview.png" />
<meta property="og:site_name" content="Parlor Puzzle Solver | Blue Prince" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Parlor Puzzle Solver | Blue Prince" />
<meta name="twitter:description" content="Solve the parlor logic puzzles from Blue Prince using this interactive, rule-based boolean logic deduction tool." />
<meta name="twitter:image" content="https://theshiftingquiet.github.io/Blue-Prince-Parlor-Solver/preview.png" />

<meta name="keywords" content="parlor puzzle, parlor solver, parlor puzzle solver, parlor hints, parlor room, parlor boxes, boxes puzzle, Blue Prince, Blue Prince parlor puzzle">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E6ESL8H13E"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E6ESL8H13E');
</script>
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Parlor Puzzle Solver | Blue Prince",
    "url": "https://theshiftingquiet.github.io/Blue-Prince-Parlor-Solver/",
    "description": "Solve the parlor logic puzzles from Blue Prince using this interactive, rule-based boolean logic deduction tool.",
    "applicationCategory": "GameUtility",
    "operatingSystem": "All",
    "browserRequirements": "Requires JavaScript",
    "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
    }
}
</script>

<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
        {
            "@type": "Question",
            "name": "How do I solve the parlor box puzzles?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "You can use this tool to evaluate all possible cases automatically given the box statements, rather than doing it by hand. Doing so will always give you the correct answer."
            }
        },
        {
            "@type": "Question",
            "name": "Are the parlor puzzles infinite?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "The puzzles are not infinite, but they do seem to be randomized (or there are a large set of them). Most of them don't have answers posted online, but you can use this tool to solve them."
            }
        },
        {
            "@type": "Question",
            "name": "Does the parlor puzzle keep getting harder?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "The parlor puzzles get as hard as 3 statements per box, but they do seem to reset or start getting easier every now and then."
            }
        }
    ]
}
</script>

<meta name="robots" content="index, follow">
<link rel="canonical" href="https://theshiftingquiet.github.io/Blue-Prince-Parlor-Solver/" />

<script src="jexl.browser.js"></script>
<script src="cropperjs.browser.js"></script>
<script src="tesseract.min.js"></script>
<script src="sweetalert.min.js"></script>

<title>Parlor Solver | Blue Prince</title>
<style>
    body {
        font-family: sans-serif;
        margin: 0;
        padding: 20px;
    }

    .box-toggle-groups {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        width: 100%;
        margin: 10px 0;
        gap: 20px;
    }
    input {
        width: 100%;
        margin: 2px 0;
    }
    button {
        margin-right: 5px;
    }
    .effects-container {
        display: flex;
        flex-wrap: wrap;
        flex-direction: row;
        margin-top: 10px;
    }
    .effects {
        margin-top: 10px;
        margin-right: 50px;
    }
    .toggle-group {
        display: flex;
        align-items: center;
        width: 220px;
        justify-content: flex-end;
    }

    .toggle-label {
        font-weight: bold;
        align-self: center;
    }

    .button-group {
        min-width: 118px;
        margin-left: 10px;
        margin-right: 40px;
        display: flex;
        flex-direction: column;
    }

    .button-group.horizontal {
        flex-direction: row;
    }

    button {
        padding: 6px 14px;
        margin-right: 6px;
        border: 1px solid #888;
        background-color: #f0f0f0;
        cursor: pointer;
        border-radius: 4px;
        font-size: 14px;
        user-select: none;
        transition: background-color 0.2s, color 0.2s;
    }

    button:hover {
        background-color: #e0e0e0;
    }

    .toggle-button {
        margin-right: 6px;
    }

    .toggle-button.active {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
    }

    .button {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
    }

    .statement-block {
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 10px;
        background-color: #fafafa;
        color: black;
    }

    .statement-block h4 {
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 16px;
        border-bottom: 1px solid #ddd;
        padding-bottom: 4px;
    }

    .statement-grid {
        display: grid;
        grid-template-columns: 1fr 2fr;
        gap: 6px 12px;
        align-items: center;
    }

    .statement-grid label {
        font-weight: 500;
    }

    .statement-grid input {
        width: 100%;
        font-family: monospace;
        font-size: 14px;
        padding: 4px;
        box-sizing: border-box;
    }

    .statement-compact-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 6px;
        font-size: 14px;
    }

    .statement-compact-table th,
    .statement-compact-table td {
        padding: 4px 6px;
        border: 1px solid #ddd;
        vertical-align: middle;
    }

    .statement-compact-table input {
        width: 100%;
        font-family: monospace;
        font-size: 14px;
        box-sizing: border-box;
    }

    .controls {
        margin-top: 20px;
        display: flex;
        justify-content: center;
        width: 100%;
    }

    .other-settings-optional-labels, .other-settings-negation-rows {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 15px 0;
    }

    .optional-label-inputs, .negation-rows {
        width: 100%;
    }

    .optional-label-inputs .toggle-button, .negation-rows .toggle-button {
        width: 50%;
        max-width: 200px;
    }

    .optional-label-inputs.button-group, .negation-rows.button-group {
        justify-content: center;
        margin-top: 5px;
    }

    #inputArea {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
    }

    .box {
        border: 1px solid #aaa;
        padding: 10px;
        flex: 1 1 300px;
        min-width: 300px;
        max-width: 100%;
        box-sizing: border-box;        
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .box:nth-child(1) {
        background-color: #9dc9ff;
    }
    .box:nth-child(2) {
        background-color: #ffffff;
    }
    .box:nth-child(3) {
        background-color: #2e2e2e;
        color: white;
    }

    .case {
        margin: 10px 0;
        border: 2px solid #333;
        padding: 10px;
        background-color: #ccffcc
    }

    #outcomeSummary {
        margin: 10px 0;
        border: 2px solid #333;
        padding: 10px;
    }

    #outcomeSummary.found-answer {
        background-color: #ccffcc;
    }

    #outcomeSummary.no-answer {
        background-color: #ffcccc;
    }

    #outcomeSummary.ambiguous-answer {
        background-color: #d5b1de;
    }

    #outcomeText {
        white-space-collapse: preserve;
    }

    .case.invalid-case {
        background-color: #ffcccc;
    }

    .case.ambiguous-case {
        background-color: #d5b1de;
    }
    
    .highlight-false {
        background-color: yellow;
    }

    .case .effect-false {
        color: red;
    }

    .case .effect-true {
        color: green;
    }

    .reasoning li {
        white-space-collapse: preserve;
        margin-bottom: 10px;
    }

    .fullscreen-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        z-index: 1000;
        padding: 50px;
        box-sizing: border-box;
        justify-content: center;
        align-items: center;
    }

    .fullscreen-modal-inner {
        background: white;
        border-radius: 8px;
        width: 100%;
        height: 100%;
        max-width: 100%;
        max-height: 100%;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        box-sizing: border-box;
    }

    .fullscreen-modal-header {
        flex: 0 0 auto;
        padding: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: white;
        z-index: 1;
    }

    .fullscreen-modal-content {
        flex: 1 1 auto;
        overflow-y: auto;
        padding: 0 20px 20px 20px;
        box-sizing: border-box;
    }

    #cropModalContent {
        display: flex;
        flex-direction: column;
        position: relative;
        height: 100%;
        gap: 12px;
    }

    #cropConfirm {
        align-self: center;
        padding: 10px 24px;
        max-width: 200px;
        width: auto;
    }

    cropper-canvas {
        flex: 1 1 auto;
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
        user-select: none;
    }

    .autogenerated {
        background-color: #edffef;
        border: 1px solid #2390f2;
        color: #7b7b7b;
        border-style: dashed;
    }

    .label-col.hidden-col {
        display: none;
    }

    .negation-row.hidden-row {
        display: none;
    }

    h1 {
        font-size: 1.2rem;
        margin: 0 0 1.2rem 0;
        font-weight: 600;
        text-align: center;
    }

    #footer {
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 1px solid #dad3d3;
        width: 100%;
        text-align: center;
    }

    #faq-header {
        margin-top: 2rem;
        font-size: 1.2rem;
        font-weight: 600;
        text-align: center;
    }

    #faq {
        font-size: 1.2rem;
    }

    #faq details {
        margin: 10px 0;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 8px;
        background-color: #f9f9f9;
    }

    #faq summary {
        cursor: pointer;
        font-weight: bold;
    }

    .paste-box {
        -moz-user-select: none;
        -khtml-user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
        user-select: none;
        white-space-collapse: preserve;

        margin-top: auto;
        background-color: #ffffff;
        width: 100%;
        height: 50px;
        border: 2px dashed #ccc;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #888;
        font-family: sans-serif;
        cursor: pointer;
        transition: border-color 0.2s;
        text-align: center;
    }

    .paste-box:hover {
        border-color: #666;
    }

    .paste-box:focus {
        outline: none;
        border-color: #007bff;
        color: #007bff;
    }

    #yt-guide {
        width: 100%;
        max-width: 960px;
        aspect-ratio: 16 / 9;
        border: none;
        margin-top: 10px;
        display: block;
    }
</style>
</head>

<body>
    <h1>Blue Prince: Parlor Puzzle Solver</h1>
    <div class="setup-controls">
        <div class="box-toggle-groups">
            <div class="toggle-group">
                <div><label class="toggle-label">Blue:</label></div>
                <div class="button-group" data-name="blueCount">
                    <button class="toggle-button" data-value="0">Blank box</button>
                    <button class="toggle-button" data-value="1">1 statement</button>
                    <button class="toggle-button active" data-value="2">2 statements</button>
                    <button class="toggle-button" data-value="3">3 statements</button>
                </div>
            </div>
            <div class="toggle-group">
                <div><label class="toggle-label">White:</label></div>
                <div class="button-group" data-name="whiteCount">
                    <button class="toggle-button" data-value="0">Blank box</button>
                    <button class="toggle-button" data-value="1">1 statement</button>
                    <button class="toggle-button active" data-value="2">2 statements</button>
                    <button class="toggle-button" data-value="3">3 statements</button>
                </div>
            </div>
            <div class="toggle-group">
                <div><label class="toggle-label">Black:</label></div>
                <div class="button-group" data-name="blackCount">
                    <button class="toggle-button" data-value="0">Blank box</button>
                    <button class="toggle-button" data-value="1">1 statement</button>
                    <button class="toggle-button active" data-value="2">2 statements</button>
                    <button class="toggle-button" data-value="3">3 statements</button>
                </div>
            </div>
        </div>
        <div class="other-settings">
            <div class="other-settings-optional-labels">
                <div>Show label statements? They are just for your own reference.</div>
                <div class="button-group horizontal optional-label-inputs" data-name="optionalLabelInputs">
                    <button class="toggle-button active show-hide-label-btn" data-value="0">Hide</button>
                    <button class="toggle-button show-hide-label-btn" data-value="1">Show</button>
                </div>
            </div>
            <div class="other-settings-negation-rows">
                <div>(Advanced) Show negations? You rarely need to edit them.</div>
                <div class="button-group horizontal negation-rows" data-name="negationRows">
                    <button class="toggle-button active show-hide-negation-btn" data-value="0">Hide</button>
                    <button class="toggle-button show-hide-negation-btn" data-value="1">Show</button>
                </div>
            </div>
        </div>
    </div>
    <div id="inputArea"></div>
    <div class="controls">
        <button onclick="calculate()">Calculate</button>
        <button onclick="clearAll()">Clear all</button>
        <button onclick="openAI()">Generate JEXL with AI</button>
        <button onclick="userAskImportFromJSON()">Import</button>
    </div>
    <div id="outcomeSummary" style="display: none;">
        <h3>Outcome</h3>
        <p id="outcomeText"></p>
    </div>
    <div id="cases"></div>

    <div id="faq">
        <h2 id="faq-header">Frequently Asked Questions</h2>
        <details open>
            <summary>How do I use this tool?</summary>

            <iframe id="yt-guide" src="https://www.youtube.com/embed/5BayAGZtNHc"></iframe>
            <p>First of all, to summarize how this works, the tool is going to go through all possible combinations and evaluate each of the statements with the assumed truthfulness, to see if it leads to a contradiction.</p>
            <p>There are two main ways to use this tool, a simple method and an advanced method.</p>
            <p>For the simple method, you don't even need to understand what these inputs and labels are: you can just follow the steps and everything should work on its own.</p>
            <p>Please note that the simple method will use AI, and AI is unreliable. Maybe my prompt can be improved - I'd be happy to check out any suggestions.</p>
            <h3>Simple method</h3>
            <ol>
                <li>Take a screenshot of the blue box, paste it in the blue box's paste zone, and press the button "Crop & OCR".</li>
                <li>Check that the text has been extracted from your screenshot correctly and fix any significant typos you see, then press "Accept" to automatically fill in the statements.</li>
                <li>Repeat the process for the white and black boxes. Alternatively, you can enable "Show label statements" in the settings and manually fill in the statements yourself.</li>
                <li>Press the button "Generate JEXL with AI" and then choose the AI of your choice. This will open a new tab with the AI tool, which will be prompted to automatically generate the JEXL expressions for each statement with all the context it needs.</li>
                <li>Wait for the AI to finish.</li>
                <li>Copy the generated codeblock and paste it into the "Import from JSON" modal that will have opened (you can re-open it with the button "Import").</li>
                <li>Press the button "Import": this will automatically fill in the JEXL expressions the AI generated for each statement.</li>
                <li>Finally, press the button "Calculate" to evaluate all possible cases and find the solution.</li>
            </ol>
            <p>The advanced method is the same, except you write the JEXL expressions yourself, rather than using the AI to generate them for you.</p>
            <p>You can read the other relevant FAQ entries below to learn more about how to write the JEXL expressions yourself, if that's something you'd like to do.</p>
        </details>
        <details>
            <summary>How does this tool work?</summary>
            <p>For the If TRUE condition - you write the logic that would follow if the statement is assumed to be true.</p>
            <p>The FALSE conditions are always direct negations of the TRUE condition (not opposite, though - negation). They are automatically filled in for you when you enter the true statements (but they represent the assumption that follows if the statement is assumed to be false).</p>
            <p>You might ask, aren't the FALSE conditions just the negation of the TRUE conditions? Yes. But sometimes, the negation is a logical paradox - you can write <code>false</code> for those cases, for example.</p>
            <p>That said, in most cases, the negation is just the same as the TRUE condition but negated, so it will be generated automatically for you as you write the If TRUE condition - but you can override it.</p>
        </details>
        <details>
            <summary>Do I have to learn JEXL?</summary>
            <p>It's recommended, because AI can be pretty stupid, but it's not absolutely necessary - you can check out the first FAQ entry "How do I use this tool?" to see how you can automate it all with AI.</p>
            <p>Essentially, the AI will translate the statements for you, and you can just copy-paste the generated codeblock into the "Import from JSON" modal.</p>
            <p>Here is the full prompt, if you'd like to use it directly (and pass the screenshots directly to the AI, rather than pasting them here for OCR):</p>
            <details>
                <summary>Open full prompt</summary>
                <pre><span id="basePromptText">You are a parlor puzzle logic translator for a restricted subset of JEXL. Your output must ONLY use this limited grammar. If a statement cannot be expressed using only these allowed constructs, fail explicitly or hard-code as needed. 
The user will supply three boxes-blue, white, black-and a numbered list of natural-language statements for each. Your job is to translate logical, freeform statements into JEXL expressions.

Available JEXL context objects and properties:

Each of `blue`, `white`, `black` (also available as `this` in its own box):

* `.color`: `"blue"` / `"white"` / `"black"`
* `.statements[]`: array of statements (strings)
* `.bools[]`: assumed truth values (bools) for the statements
* `.oneIsTrue`, `.twoIsTrue`, `.threeIsTrue`: true if the 1st / 2nd / 3rd statement is true
* `.oneIsFalse`, `.twoIsFalse`, `.threeIsFalse`: true if the 1st / 2nd / 3rd statement is false
* `.trueCount`, `.falseCount`: number of true/false statements
* `.isAllTrue`, `.isAllFalse`, `.isMixed`: box has only true, only false, or a mix
* `.hasGems`, `.isNotEmpty`, `.notEmpty`: box is assumed to contain gems
* `.isEmpty`, `.hasNoGems`, `.empty`: box is assumed empty

From the shared `context` object:

* `.trueBoxCount`, `.falseBoxCount`: count of boxes with all-true or all-false statements
* `.trueStatementCount`, `.falseStatementCount`: total number of true/false statements across all boxes
* `.boxWithGems`: reference to the box assumed to hold the gems
* `.boxesWithoutGems`, `.emptyBoxes[]`: array of boxes assumed to be empty

When solving, please ensure to consider the following:
1. Each box can have up to 3 statements. The user will provide every statement.
2. A box is considered "true" if it ONLY has true statements, and "false" if it ONLY has false statements. If it has a mix of both, it's mixed.

Notes:
* Statements may reference other statements in the puzzle. 'That', 'this', and similar references typically refer to immediately preceding statements or contextually obvious referents (like "this box" is the box the statement is in, "that's not true" is likely referring to the previous statement of the same box).
* If certain statements are impossible or difficult to reprent as JEXL (such as "any statement with an odd number of words"), pre-compute or hard-code the logic. E.g, if a statement says "A statement with an odd number of words is always true", you can look at the statements, gather in your head which ones have an odd number of words, and then write the JEXL expression where you hard-code which statements are expected to be true (the ones with an odd number of words).
* For cases where JEXL statements had to be inferred and weren't "direct" translations, please provide a comment in notes under the output codeblock on what inferrences you made and what they were based on.
* Only use JEXL-safe expressions. Do NOT use string methods (e.g., .split(), .join(), .length), loops, or any operations not explicitly listed in the available context or standard JEXL syntax. Any property used must be directly accessible from the provided context objects. If a statement requires analysis (like word counts), compute those manually during translation and hard-code their truth conditions.
* You have four additional allowed custom functions: "join(array, separator)", "len(arr_or_str)", "count(arr_or_str_haystack, needle)" and "split(string, separator)". These are the only functions you can use. You can use them to join, count or split strings and arrays, but nothing else. You cannot call them as methods, you must call them like join(blue.statements, ", ")
* Only reference .statements[n], .bools[n], etc. for existing statements. Do not assume all three statements exist in every box, look at the provided counts and stay within them.
Boolean: &amp;&amp;, ||, !
Comparison: ==, !=, &gt;, &lt;, &gt;=, &lt;=
Avoid comparing by reference, as objects are copied.

Examples: 
"exactly two true in blue" -&gt; blue.trueCount == 2
"the empty boxes has at least 1 false statement" -&gt; context.emptyBoxes[0].falseCount &gt; 0 &amp;&amp; context.emptyBoxes[1].falseCount &gt; 0
"gems are in the blue box" -&gt; blue.hasGems or context.boxWithGems.color == "blue"
"this box is blue" -&gt; this.color == "blue"

If you can successfully translate anything, you must respond with a codeblock containing JSON data matching the schema above, without including the schema itself. If you have any notes, you may add them below the codeblock, but the codeblock itself must be valid JSON that matches the schema.
If a statement cannot be accurately translated using only the allowed JEXL grammar due to unclear meaning, you must not return JSON. Instead, respond with only a follow-up question, asking the user to clarify or guide the translation. Do not assume or attempt to resolve ambiguous phrasing on your own.

Schema:
```
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "blue": { "$ref": "#/definitions/box" },
    "white": { "$ref": "#/definitions/box" },
    "black": { "$ref": "#/definitions/box" }
  },
  "required": ["blue", "white", "black"],
  "definitions": {
    "statement": {
      "type": "object",
      "properties": {
        "statement_text": { "type": "string" },
        "jexl_code": { 
          "type": "string",
          "description": "A valid JEXL expression using only boolean operators, comparisons, direct property access, array indexing, and these functions: split(string, separator), join(array, separator), len(arr_or_str). Do NOT use any unlisted method calls like .split(), .join(), .length, or any unlisted functions."
        }
      },
      "required": ["statement", "jexl_code"]
    },
    "box": {
      "type": "object",
      "properties": {
        "count": { "type": "number" },
        "statements": {
          "type": "array",
          "items": { "$ref": "#/definitions/statement" }
        }
      },
      "required": ["count", "statements"]
    }
  }
}
```


User input:

</span>
Blue:
1. Statement 1
2. Statement 2 (if any)

White:
1. Statement 1
2. Statement 2 (if any)

Black:
1. Statement 1
2. Statement 2 (if any)
3. Statement 3 (if any)
</pre>
        </details>
        <details>
            <summary>How do I deal with statements that just don't make any sense?</summary>
            <p>A statement like "this box is of no help at all", for example, right?</p>
            <p>That's somewhat of a subjective box, but most of those boxes are usually false, or paradoxical enough to be considered false.</p>
            <p>For those, you can provide <code>false</code> as the condition for the TRUE case, and <code>true</code> as the condition for the FALSE case, which would mean that this statement cannot be true (but it logically works if we assume it's false).</p>
        </details>
        <details>
            <summary>How does the tool work?</summary>
            <p>Essentially, it goes through all 6-18+ possible combinations of 1-3 true/false statements.</p>
            <p>Then, for each case, goes through all 3 possible gem placements.</p>
            <p>It evaluates each statement with its assumed truthfulness.</p>
            <p>If any of the statements evaluate to false - that's a contradiction.</p>
            <p>If any of the 3 possible gem placements work out with no contradictions across all statements - that's a valid answer.</p>
            <p>In the end, if there's only one valid answer - that's your definitive answer.</p>
            <p>If there's multiple - there's some sort of ambiguity that you can resolve by looking at the page's reasoning for each of the cases.</p>
            <p>If there are none - there must be some logical error in how some of the statements are constructed.</p>
        </details>
        <details>
            <summary>I'm getting an ambiguity error</summary>
            <p>The parlor puzzles are designed in a way that they can be solved with logic, without any guessing necessary.</p>
            <p>This means, if you are getting an ambiguity - there is something missing: perhaps you made a typo in one of the statements, perhaps you missed a statement, maybe you missed a constraint that a statement implies, perhaps you misinterpreted the statement.</p>
            <p>If you have any questions, or if you feel like the tool isn't working as expected, feel free to post an issue on Github.</p>
        </details>
        <details>
            <summary>I'm getting a no possible answers error</summary>
            <p>The parlor puzzles always have at least one possible answer, so if you're getting a 0 possible answers error - there is something wrong with the statements.</p>
            <p>Double-check all your statements and make sure they are all logically consistent, and that you're not adding some constraint that isn't implied by the statements.</p>
            <p>For example, think about the statement "a box next to this box has only true statements". That does not imply that there are no false boxes next to the box - just that there is SOME box next to it that has only true statements.</p>
        </details>
        <details>
            <summary>I'm getting an alert with some JEXL error</summary>
            <p>You must have made some syntax error in the JEXL expression, or perhaps you tried accessing a property that doesn't exist.</p>
            <p>To prevent common typos, I've made it so that access to properties that don't exist will throw an error, rather than returning undefined.</p>
            <p>That's because you wouldn't want <code>white.iSTrue</code> to return undefined (falsy), even though <code>white.isTrue</code> may have been true.</p>
        </details>
        <details>
            <summary>What's the advanced way, how do I understand or write the JEXL logical expressions myself?</summary>
            <p>The expressions are JEXL (JavaScript Expression Language) expressions, which is pretty similar to JavaScript. For example, you can use <code>white.isEmpty || (black.isAllTrue && black.hasGems)</code> to represent a statement like "the white box is empty or the black box is true AND contains gems".</p>
            <p>You can find more examples in the Help modal.</p>
            <p>If you'd like to read up more on how to write JEXL statements, you can do so <a href="https://github.com/TomFrost/jexl">here</a>, though the examples should be more than enough to get you started, and most of the basic JS syntax will work as you would expect it.</p>
            <p>Your JEXL condition will have access to the following objects (and each will have a different value when considering each possibility) - blue, white, black, each object with:</p>
            <pre><code>{
    "color": "blue" or "white" or "black",
    "oneIsTrue": true if blue 1 statement is assumed true in this case, false otherwise,
    "oneIsFalse": true if blue 1 statement is assumed false in this case, false otherwise,
    "twoIsTrue": true if blue 2 statement is assumed true in this case, false otherwise,
    "twoIsFalse": true if blue 2 statement is assumed false in this case, false otherwise,
    "threeIsTrue": true if blue 3 statement is assumed true in this case, false otherwise,
    "threeIsFalse": true if blue 3 statement is assumed false in this case, false otherwise,
    "statements": array of strings, each representing the text of the statement in this box (statements[0] = blue 1 statement, statements[1] = blue 2 statement, etc.)
    "bools": array of booleans, each representing the truthiness of the statement in this box (bools[0] = blue.oneIsTrue, bools[1] = blue.twoIsTrue, etc.)
    "isAllTrue" or "isTrue" or "allIsTrue": true if all of the statements in this box are assumed true in this case, false otherwise
    "isAllFalse" or "isFalse" or "allIsFalse": true if all of the statements in this box are assumed false in this case, false otherwise
    "isMixed": true if this box has at least one true and at least one false statement (so it's neither an all-true nor all-false box)
    "trueCount": number of statements that are assumed true in this case
    "falseCount": number of statements that are assumed false in this case
    "isEmpty" or "empty" or "hasNoGems": true if this sub-case assumes it's empty
    "hasGems" or "notEmpty" or "isNotEmpty": true if this sub-case assumes it has gems
}</code></pre>
                        <p>You will also have access to the object "context" with the following properties:</p>
                        <pre><code>{
    "trueBoxCount" or "allTrueBoxCount": number of boxes that are assumed to have only true statements in this case
    "falseBoxCount" or "allFalseBoxCount": number of boxes that are assumed to have only false statements in this case
    "trueStatementCount": number of statements that are assumed true in this case across all boxes
    "falseStatementCount": number of statements that are assumed false in this case across all boxes
    "boxWithGems": a reference to the box object that is assumed to have gems in this sub-case
    "boxesWithoutGems" or "emptyBoxes": an array of references to the box objects that are assumed to be empty in this sub-case
}</code></pre>
        </details>
        <details>
            <summary>JEXL doesn't support some advanced functions I'm trying to use</summary>
            <p>JEXL is more of a subset of JavaScript, so it doesn't support all of the functions you might be used to.</p>
            <p>Though, you can always add your own functions to JEXL, if you are familiar enough with JavaScript.</p>
            <p>For example, you could add a function <code>countAllWords</code> by opening the devtools console and typing like this:</p>
            <pre><code>
                Jexl.addFunction('countAllWords', box => {
                    return box.statements.reduce((acc, statement) => acc + (statement ? statement.split(' ').length : 0), 0);
                });
            </code></pre>
            <p>You could then use it in your JEXL expressions like this:</p>
            <pre><code>
                countAllWords(blue) > 1
            </code></pre>
        </details>
        <details>
            <summary>What are the optional labels for?</summary>
            <p>The labels (statements) are just for your own reference. They don't affect the logic of the statements in any way.</p>
            <p>Basically, if you plan to look through each of the possible cases to troubleshoot - you can write the labels there to help you remember what each statement means.</p>
            <p>You can also access these labels through the JEXL statements in case you got a statement like "The box with more than 8 words" and you don't want to count by hand.</p>
        </details>
        <details>
            <summary>The statement is too complex to represent it as a JEXL statement</summary>
            <p>Usually, even when it feels like it's hard to translate it into a logical statement - it is still possible, without any loss of data.</p>
            <p>For example, if it says "a box next to this box has only true statements" - you don't need to try and figure out how to represent "next to" in a logical statement.</p>
            <p>Instead, you can simply look at which boxes are next to this box, then, let's say it's the blue and black boxes - write: <code>blue.isAllTrue || black.isAllTrue</code>.</p>
        </details>
        <details>
            <summary>How do I share my inputs with someone, do I have to copy-paste each statement?</summary>
            <p>You can share your inputs with someone by copying the URL of the page after you have filled out the inputs and pressed Calculate (or after you've scanned a screenshot, or after you've imported JSON).</p>
            <p>When you do any of those things, the page generates a unique URL that contains all of your inputs and the calculated results and appends it to the URL.</p>
            <p>This is also edited into your navigation history, so if you refresh or go back - your inputs will be preserved.</p>
        </details>
        <details>
            <summary>I would like to contribute to the project, report a bug, viuew the source code, or suggest a feature</summary>
            <p>You're more than welcome to open an issue or a pull request <a href="https://github.com/TheShiftingQuiet/Blue-Prince-Parlor-Solver">in the Github repository!</a></p>
        </details>
    </div>

    <footer id="footer">
        <p>You can find the source code <a href="https://github.com/TheShiftingQuiet/Blue-Prince-Parlor-Solver">in the Github repository</a></p>
    </footer>

    <div id="cropModal" class="fullscreen-modal" style="display:none;">
        <div id="cropModalInner" class="fullscreen-modal-inner">
            <div id="cropModalHeader" class="fullscreen-modal-header">
                <h2>Optical Character Recognition</h2>
                <button id="closeCropModalBtn" onclick="closeCropModal()" style="margin-top: 20px;">Close</button>        
            </div>
            <div id="cropModalContent" class="fullscreen-modal-content">
                <p>Please try and only select the area of the image that contains the text you want to extract (just the label of the box). Try to take screenshots with as good an angle as you can. The more precise you are, the better the results will be.</p>
                <!-- that's just a transparent 1x1 pixel for cropperjs to initialize with, the warning in the console was annoying -->
                <img id="cropImage" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw=="/>
                <button id="cropConfirm" class="button">Crop & OCR</button>
            </div>
        </div>
    </div>
</body>

<script>
const maxPossibleStatements = 3;
const boxNames = ['blue', 'white', 'black'];
// just a sanity check - we make sure none of the box names include any HTML characters, since we treat this as safe
const unsafeChars = ['<', '>', '&', '"', "'", '`'];
boxNames.forEach(boxName => {
    if (unsafeChars.some(char => boxName.includes(char))) {
        let err = `Box name "${boxName}" contains unsafe characters.`;
        console.error(err);
        alert(err);
        throw new Error(err);
    }
});

function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function uppercase(str) {
    return str.toUpperCase();
}

function escapeHTML(str) {
    return str.replace(/[&<>"']/g, match => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
    }[match]));
}

Jexl.addFunction('split', (str, separator) => {
    if (typeof str !== 'string') {
        throw new Error('split() expects a string as the first argument');
    }
    if (typeof separator !== 'string') {
        throw new Error('split() expects a string as the second argument');
    }
    return str.split(separator);
});

Jexl.addFunction('join', (array, separator) => {
    if (!Array.isArray(array)) {
        throw new Error('join() expects an array as the first argument');
    }
    if (typeof separator !== 'string') {
        throw new Error('join() expects a string as the second argument');
    }
    return array.join(separator);
});

Jexl.addFunction('len', (arrOrStr) => {
    if (Array.isArray(arrOrStr)) {
        return arrOrStr.length;
    } else if (typeof arrOrStr === 'string') {
        return arrOrStr.length;
    } else {
        throw new Error('len() expects an array or string as the argument');
    }
});

Jexl.addFunction('count', (haystack, needle) => {
    if (!Array.isArray(haystack) && typeof haystack !== 'string') {
        throw new Error('count() expects an array or string as the first argument');
    }

    let count = 0;
    if (Array.isArray(haystack)) {
        for (const item of haystack) {
            if (item === needle) {
                count++;
            }
        }
    } else {
        haystack = haystack.toLowerCase();
        // we count the number of times the needle appears in the haystack
        const needleLower = `${needle}`.toLowerCase();
        let pos = haystack.indexOf(needleLower);
        while (pos !== -1) {
            count++;
            pos = haystack.indexOf(needleLower, pos + needleLower.length);
        }
    }
    return count;
});

const state = {
    inputs: {},
    cases: [],
    // we keep track of the last known JS codes for each box and statement for reasons you can find in the onTrueJsConditionBlur function
    lastTrueJsCodes: {},
    cropper: null,
    currentCropperBoxName: null
};

function getStatementsCount(boxName) {
    return parseInt(document.querySelector(`.button-group[data-name="${boxName}Count"] .toggle-button.active`).dataset.value);
}

function tempCompactMode(caseWidth = 800, statementWidth = 200) {
    // I'll use this from time to time until I add polished compact mode for the public
    const existingStyle = document.getElementById('reasoning-style');
    if (existingStyle) {
        existingStyle.remove();
    }

    const style = document.createElement('style');
    style.id = 'reasoning-style';
    style.textContent = `
.reasoning ol {
    display: flex;
    gap: 25px;
}

.case {
    width: ${caseWidth}px;
}

.effects {
    width: ${statementWidth}px;
}

#cases {
    display: flex;
    flex-wrap: wrap;
}
`;
    document.head.appendChild(style);
}

function tempCompactModeOff() {
    const style = document.getElementById('reasoning-style');
    if (style) {
        style.remove();
    }
}


function generateInputs() {
    const inputArea = document.getElementById('inputArea');

    boxNames.forEach(boxName => {
        const count = getStatementsCount(boxName);

        let boxDiv = document.querySelector(`#box_${boxName}`);
        if (!boxDiv) {
            boxDiv = document.createElement('div');
            boxDiv.classList.add('box');
            boxDiv.id = `box_${boxName}`;
            boxDiv.innerHTML = `<h3>${capitalize(boxName)}</h3>`;
            for (let i = 0; i < maxPossibleStatements; i++) {
                const statementBlock = document.createElement('div');
                statementBlock.classList.add('statement-block');
                statementBlock.id = `${boxName}_statement_${i + 1}`;
                let labelClasses = `label-col${optionalLabelsColIsHidden() ? ' hidden-col' : ''}`;
                let negationClasses = `negation-row${negationRowsAreHidden() ? ' hidden-row' : ''}`;
                statementBlock.innerHTML = `
                    <h4>Statement ${i + 1}</h4>
                    <table class="statement-compact-table">
                        <thead>
                            <tr>
                                <th></th>
                                <th class="${labelClasses}">Label (optional)</th>
                                <th>Condition (JS/JEXL)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>If TRUE</strong></td>
                                <td class="${labelClasses}"><input type="text" id="${boxName}_s${i + 1}_true_label" /></td>
                                <td><input type="text" id="${boxName}_s${i + 1}_true_code" oninput="onTrueJsConditionModified('${boxName}', ${i + 1})" /></td>
                            </tr>
                            <tr class="${negationClasses}">
                                <td><strong>If FALSE</strong></td>
                                <td class="${labelClasses}"><input type="text" id="${boxName}_s${i + 1}_false_label" /></td>
                                <td><input type="text" id="${boxName}_s${i + 1}_false_code" oninput="onFalseJsConditionModified('${boxName}', ${i + 1})" /></td>
                            </tr>
                        </tbody>
                    </table>
                `;
                boxDiv.appendChild(statementBlock);
            }
            inputArea.appendChild(boxDiv);

            let pasteBox = document.createElement('div');
            pasteBox.classList.add('paste-box');
            pasteBox.setAttribute('tabindex', '0');
            pasteBox.setAttribute('data-box-name', boxName);
            pasteBox.textContent = 'Paste box screenshot here to autofill\n(Click, then Ctrl+V)';
            pasteBox.addEventListener('click', () => {
                pasteBox.focus();
            });
            pasteBox.addEventListener('paste', handlePasteBoxPaste);
            boxDiv.appendChild(pasteBox);
        }

        for (let i = 0; i < maxPossibleStatements; i++) {
            const block = document.getElementById(`${boxName}_statement_${i + 1}`);
            block.style.display = (i < count) ? '' : 'none';
        }
    });
}

function toggleOptionalLabelInputs(show) {
    const labelColumns = document.querySelectorAll('.label-col');
    labelColumns.forEach(col => {
        if (show) {
            col.classList.remove('hidden-col');
        } else {
            col.classList.add('hidden-col');
        }
    });
}

function toggleNegations(show) {
    const negationRows = document.querySelectorAll('.negation-row');
    negationRows.forEach(row => {
        if (show) {
            row.classList.remove('hidden-row');
        } else {
            row.classList.add('hidden-row');
        }
    });
}

function optionalLabelsColIsHidden() {
    return parseInt(document.querySelector(`.button-group[data-name="optionalLabelInputs"] .toggle-button.active`).dataset.value) === 0;
}

function negationRowsAreHidden() {
    return parseInt(document.querySelector(`.button-group[data-name="negationRows"] .toggle-button.active`).dataset.value) === 0;
}

function negateTrueJsCode(code) {
    const cleaned = code.trim().replace(/;+\s*$/, '');
    return `!( ${code} )`;
}

function onTrueJsConditionModified(boxName, statementNumber) {
    // statementNumber is 1-indexed
    const trueInput = document.getElementById(`${boxName}_s${statementNumber}_true_code`);
    const falseInput = document.getElementById(`${boxName}_s${statementNumber}_false_code`);
    const trueValue = trueInput.value;

    let previousTrueJsCode = state.lastTrueJsCodes[`${boxName}_${statementNumber}`];
    state.lastTrueJsCodes[`${boxName}_${statementNumber}`] = trueInput.value;

    if (falseInput.value.trim().length > 0 && negateTrueJsCode(previousTrueJsCode) !== falseInput.value) {
        // the false input is not empty and was user-written, we don't override it
        return;
    }

    // the false input is either empty, or it was autogenerated
    // we set it to empty if the true input is empty, or we autogenerate it if the true input is not empty
    if (trueValue.trim().length === 0) {
        falseInput.value = '';
    } else {
        falseInput.value = negateTrueJsCode(trueValue);
    }

    onFalseJsConditionModified(boxName, statementNumber);
}

function onFalseJsConditionModified(boxName, statementNumber) {
    // we set the autogenerated class if the code is a negation of the true code, removing it if it's not
    const falseInput = document.getElementById(`${boxName}_s${statementNumber}_false_code`);

    let trueJsCode = state.lastTrueJsCodes[`${boxName}_${statementNumber}`];
    let negatedJsCode = trueJsCode == null ? null : negateTrueJsCode(state.lastTrueJsCodes[`${boxName}_${statementNumber}`]);

    if (negatedJsCode == null || falseInput.value.trim() !== negatedJsCode.trim()) {
        falseInput.classList.remove('autogenerated');
    } else {
        falseInput.classList.add('autogenerated');
    }
}

function generateCases() {
    document.getElementById('cases').innerHTML = '';
    state.cases = [];

    const statementCounts = boxNames.map(boxName => getStatementsCount(boxName));
    const totalCases = [];

    function generateCombos(depth = 0, current = []) {
        if (depth === boxNames.length) {
            // blank boxes are never all-true or all-false, they're always the "other" option
            const nonBlankBoxes = current.filter(arr => arr.length > 0);

            if (nonBlankBoxes.length === 0) {
                return;
            }

            // must have one all TRUE and one all FALSE
            const allTrue = nonBlankBoxes.some(arr => arr.every(x => x));
            const allFalse = nonBlankBoxes.some(arr => arr.every(x => !x));
            if (allTrue && allFalse) {
                totalCases.push(current);
            }
            return;
        }
        const size = statementCounts[depth];
        const max = 1 << size;
        for (let i = 0; i < max; i++) {
            const combo = [];
            for (let j = 0; j < size; j++) {
                combo.push(Boolean(i & (1 << j)));
            }
            generateCombos(depth + 1, current.concat([combo]));
        }
    }

    generateCombos();
    totalCases.forEach((combo, caseIndex) => {
        const caseDiv = document.createElement('div');
        caseDiv.className = 'case';
        caseDiv.dataset.caseNumber = caseIndex + 1;
        let effects = '<div class="effects-container">';
        boxNames.forEach((boxName, boxIndex) => {
            const count = combo[boxIndex].length;
            const part = `<b><u>${capitalize(boxName)} (${combo[boxIndex].map(v => v ? '<span class="effect-span effect-true">TRUE</span>' : '<span class="effect-span effect-false">FALSE</span>').join(' / ')}):</u></b><br>` +
                combo[boxIndex].map((assumedTrue, statementIndex) => {
                    let { displaySafeHTML } = generateStatementSafeHTML(boxName, statementIndex, assumedTrue);

                    return `<span class="stmt" data-box-name="${boxName}" data-statement-index="${statementIndex}" data-assumed-true="${assumedTrue}">${statementIndex + 1}. ${displaySafeHTML}</span>`;
                }).join('<br>');
            effects += `<div class="effects">${part}</div>`;
        });
        effects += '</div>';
        let reasoning = '<div class="reasoning"></div>';

        caseDiv.innerHTML = `<h3>CASE ${caseIndex + 1}</h3>${effects}${reasoning}`;
        document.getElementById('cases').appendChild(caseDiv);
        state.cases.push({
            combo,
            element: caseDiv
        });
    });
}

function getStatementText(boxName, idx, trueOrFalse) {
    const labelId = `${boxName}_s${idx + 1}_${trueOrFalse}_label`;
    const codeId = `${boxName}_s${idx + 1}_${trueOrFalse}_code`;
    const labelEl = document.getElementById(labelId);
    const codeEl = document.getElementById(codeId);
    const labelVal = labelEl ? labelEl.value.trim() : '';
    const codeVal = codeEl ? codeEl.value.trim() : '';
    if (labelVal) {
        return labelVal;
    }
    if (codeVal) {
        return codeVal;
    }
    return '';
}

// we get it from the DOM so that there's only one source of truth
const gptPromptBase = document.getElementById('basePromptText').textContent;

function generateUserPromptString() {
    let promptUserPart = '';

    let i = 0;
    for (let boxName of boxNames) {
        const count = getStatementsCount(boxName);
        promptUserPart += `${capitalize(boxName)}:\n`;

        for (let i = 0; i < count; i++) {
            let text = getStatementText(boxName, i, true);
            if (!text) {
                text = '(empty statement)';
            }

            promptUserPart += `${i + 1}. ${text}\n`;
        }

        if (i++ < boxNames.length - 1) {
            promptUserPart += '\n';
        }
    }

    return promptUserPart;
}

function openAI() {
    let userPart = generateUserPromptString();
    Swal.fire({
        title: 'Choose AI',
        showCancelButton: false,
        showConfirmButton: false,
        html: `
            <p>Select the AI you want to use for generating the prompt. The AI tool you choose will open in a new tab, and it will automatically receive the following input (along with a base prompt for its instructions):</p>
            <textarea id="prompt-edit-area" style="width:100%;height:200px;">${escapeHTML(userPart)}</textarea>
            <div style="margin-top: 1em; text-align: center;">
                <button id="btn-gpt" class="swal2-confirm swal2-styled" style="background-color: #4CAF50;">ChatGPT</button>
                <button id="btn-claude" class="swal2-cancel swal2-styled" style="background-color: #FF9800;">Claude</button>
                <button id="btn-discard" class="swal2-deny swal2-styled" style="background-color: #f44336;">Cancel</button>
            </div>
        `,
        didOpen: () => {
            const textarea = document.getElementById('prompt-edit-area');

            document.getElementById('btn-gpt').addEventListener('click', () => {
                Swal.close();
                // we spawn this in the background so that when the user is back, they can put the results in
                userAskImportFromJSON();
                openGpt(gptPromptBase + textarea.value);
            });

            document.getElementById('btn-claude').addEventListener('click', () => {
                Swal.close();
                // we spawn this in the background so that when the user is back, they can put the results in
                userAskImportFromJSON();
                openClaude(gptPromptBase + textarea.value);
            });

            document.getElementById('btn-discard').addEventListener('click', () => {
                // we just discard it
                Swal.close();
            });
        }
    });
}

async function userAskImportFromJSON() {
    let result = await Swal.fire({
        title: 'Import from JSON',
        text: 'Paste the JSON (e.g. if you just had it generated by the AI)',
        input: 'textarea',
        inputLabel: 'Paste your JSON here',
        inputPlaceholder: 'Paste your JSON here...',
        showCancelButton: true,
        confirmButtonText: 'Import',
        cancelButtonText: 'Cancel',
        preConfirm: (value) => {
            try {
                const parsed = JSON.parse(value);
                if (!isValidSchema(parsed)) {
                    throw new Error("Invalid structure, please make sure it follows the specified JSON schema.");
                }
                return parsed;
            } catch (e) {
                Swal.showValidationMessage(`Invalid JSON: ${e.message}`);
            }
        }
    });

    if (!result.isConfirmed) {
        return;
    }

    const parsed = result.value;
    try {
        loadStateFromJSON(parsed, schemaTypes.GPT_IMPORT);
    }
    catch (e) {
        console.error("Failed to load state from JSON:", e);
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'Failed to load state from JSON. Please check the console for more details.'
        });
        return;
    }

    // success, we serialize it to URL
    serializeStateToUrl();
}

function openGpt(prompt) {
    const encodedPrompt = encodeURIComponent(prompt);
    const url = `https://chat.openai.com/?q=${encodedPrompt}`;
    window.open(url, '_blank');
}

function openClaude(prompt) {
    const encodedPrompt = encodeURIComponent(prompt);
    const url = `https://claude.ai/new?q=${encodedPrompt}`;
    window.open(url, '_blank');
}

function clearCalculations() {
    state.cases.forEach(({
        element
    }) => {
        element.classList.remove('invalid-case');
        element.classList.remove('ambiguous-case');
        element.querySelectorAll('.stmt').forEach(span => span.classList.remove('highlight-false'));
    });
}

function clearAll() {
    state.cases = [];
    document.getElementById('cases').innerHTML = '';
    boxNames.forEach(boxName => {
        // we clear ALL, the maximum
        for (let i = 0; i < maxPossibleStatements; i++) {
            for (let stateKey of ['true', 'false']) {
                const labelId = `${boxName}_s${i + 1}_${stateKey}_label`;
                const codeId = `${boxName}_s${i + 1}_${stateKey}_code`;
                const labelEl = document.getElementById(labelId);
                const codeEl = document.getElementById(codeId);
                if (labelEl) {
                    labelEl.value = '';
                }
                if (codeEl) {
                    codeEl.value = '';
                }
                codeEl.classList.remove('autogenerated');
            }
        }
    });

    document.getElementById('outcomeSummary').style.display = 'none';
    document.getElementById('outcomeText').textContent = '';

    // we also remove the URL and the history
    const url = new URL(window.location);
    url.search = '';
    history.replaceState({}, '', url);

    // and we reset the box counts to 2 statements for each
    boxNames.forEach(boxName => {
        const group = document.querySelector(`.button-group[data-name="${boxName}Count"]`);
        const buttons = group.querySelectorAll('.toggle-button');
        buttons.forEach(button => {
            button.classList.remove('active');
            if (button.dataset.value === '2') {
                button.classList.add('active');
            }
        });
    });
    generateInputs();
}

const schemaTypes = {
    SERIALIZED_STATE: 'SERIALIZED_STATE',
    GPT_IMPORT: 'GPT_IMPORT'
}

function isValidSchema(params, schemaType) {
    /*
If schemaType is schemaTypes.SERIALIZED_STATE, we expect this schema:

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "blue": { "$ref": "#/definitions/box" },
    "white": { "$ref": "#/definitions/box" },
    "black": { "$ref": "#/definitions/box" }
  },
  "required": ["blue", "white", "black"],
  "definitions": {
    "statement": {
      "type": "object",
      "properties": {
        "true": {
          "type": "object",
          "properties": {
            "label": { "type": "string" },
            "jexl_code": { "type": "string" }
          },
          "required": ["label", "jexl_code"]
        },
        "false": {
          "type": "object",
          "properties": {
            "label": { "type": "string" },
            "jexl_code": { "type": "string" }
          },
          "required": ["label", "jexl_code"]
        }
      },
      "required": ["true", "false"]
    },
    "box": {
      "type": "object",
      "properties": {
        "count": { "type": "number" },
        "statements": {
          "type": "array",
          "items": { "$ref": "#/definitions/statement" }
        }
      },
      "required": ["count", "statements"]
    }
  }
}

    If schemaType is schemaTypes.GPT_IMPORT, we expect this simplified schema:
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "blue": { "$ref": "#/definitions/box" },
    "white": { "$ref": "#/definitions/box" },
    "black": { "$ref": "#/definitions/box" }
  },
  "required": ["blue", "white", "black"],
  "definitions": {
    "statement": {
      "type": "object",
      "properties": {
        "statement_text": { "type": "string" },
        "jexl_code": { 
          "type": "string",
          "description": "A valid JEXL expression using only boolean operators, comparisons, direct property access, array indexing, and these functions: split(string, separator), join(array, separator). Do NOT use any unlisted method calls like .split(), .join(), or any unlisted functions."
        }
      },
      "required": ["statement_text", "jexl_code"]
    },
    "box": {
      "type": "object",
      "properties": {
        "count": { "type": "number" },
        "statements": {
          "type": "array",
          "items": { "$ref": "#/definitions/statement" }
        }
      },
      "required": ["count", "statements"]
    }
  }
}
    */
    if (typeof params !== 'object' || params === null) {
        return false;
    }

    for (const boxName of boxNames) {
        const box = params[boxName];
        if (!box || typeof box.count !== 'number' || !Array.isArray(box.statements)) {
            return false;
        }

        if (box.statements.length !== box.count) {
            return false;
        }

        for (const statement of box.statements) {
            if (!statement) {
                return false;
            }

            if (schemaType === schemaTypes.GPT_IMPORT) {
                if (typeof statement.statement_text !== 'string' || typeof statement.jexl_code !== 'string') {
                    return false;
                }
            } else if (schemaType === schemaTypes.SERIALIZED_STATE) {
                for (const stateType of ['true', 'false']) {
                    const state = statement[stateType];
                    if (!state || typeof state.label !== 'string' || typeof state.jexl_code !== 'string') {
                        return false;
                    }
                }
            }
        }
    }

    return true;
}

function serializeStateToUrl() {
    const params = {};

    for (let boxName of boxNames) {
        const count = getStatementsCount(boxName);
        params[boxName] = { count, statements: [] };

        for (let i = 0; i < count; i++) {
            const statement = {};
            for (let stateType of ['true', 'false']) {
                const labelId = `${boxName}_s${i + 1}_${stateType}_label`;
                const codeId = `${boxName}_s${i + 1}_${stateType}_code`;
                const labelEl = document.getElementById(labelId);
                const codeEl = document.getElementById(codeId);
                if (labelEl && codeEl) {
                    statement[stateType] = {
                        label: labelEl.value,
                        jexl_code: codeEl.value,
                    };
                }
            }
            params[boxName].statements.push(statement);
        }
    }

    const encoded = base64UrlEncode(JSON.stringify(params));
    const url = new URL(window.location);
    url.search = `data=${encoded}`;
    history.replaceState({}, '', url);
}


function loadStateFromJSON(json, schemaType) {
    if (!isValidSchema(json, schemaType)) {
        throw new Error("Invalid structure");
    }

    for (let boxName of boxNames) {
        const boxState = json[boxName];
        if (!boxState) {
            continue;
        }

        const group = document.querySelector(`.button-group[data-name="${boxName}Count"]`);
        if (!group) {
            continue;
        }
        
        for (let toggleButton of group.querySelectorAll('.toggle-button')) {
            toggleButton.classList.toggle('active', toggleButton.dataset.value === String(boxState.count));
        }
    }

    generateInputs();

    for (let boxName of boxNames) {
        const boxState = json[boxName];
        if (!boxState) {
            continue;
        }

        for (let i = 0; i < boxState.count; i++) {
            const statement = boxState.statements[i];
            if (!statement) {
                continue;
            }

            if (schemaType === schemaTypes.SERIALIZED_STATE) {
                for (let stateType of ['true', 'false']) {
                    const data = statement[stateType];

                    const labelId = `${boxName}_s${i + 1}_${stateType}_label`;
                    const codeId = `${boxName}_s${i + 1}_${stateType}_code`;

                    const labelEl = document.getElementById(labelId);
                    const codeEl = document.getElementById(codeId);

                    if (labelEl) {
                        labelEl.value = data?.label || '';
                    }
                    if (codeEl) {
                        codeEl.value = data?.jexl_code || '';
                    }
                }
            } else if (schemaType === schemaTypes.GPT_IMPORT) {
                const labelId = `${boxName}_s${i + 1}_true_label`;
                const codeId = `${boxName}_s${i + 1}_true_code`;

                const labelEl = document.getElementById(labelId);
                const codeEl = document.getElementById(codeId);

                // we don't override if the GPT input is empty
                // in fact, let's just not touch the labels at all - GPT only needs to worry about writing right jexl code
                // we'll still include it in the schema so that its text predictive nature works better (since it'll be more likely to write code that makes sense for the given label)
                // if (labelEl && statement.statement_text && statement.statement_text.trim().length > 0) {
                //    labelEl.value = statement.statement_text || '';
                // }
                if (codeEl && statement.jexl_code && statement.jexl_code.trim().length > 0) {
                    codeEl.value = statement.jexl_code || '';
                    // if the code isn't empty, we also autogenerate the false code (even if it has input)
                    // we trigger that by setting the false statement to empty and then calling the onTrueJsConditionModified function
                    const falseInput = document.getElementById(`${boxName}_s${i + 1}_false_code`);
                    if (falseInput) {
                        falseInput.value = '';
                        onTrueJsConditionModified(boxName, i + 1);
                    }
                }
            }
        }
    }
}

function base64UrlEncode(str) {
    const base64 = btoa(str);
    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

function base64UrlDecode(base64) {
    base64 = base64.replace(/-/g, '+').replace(/_/g, '/');
    
    while (base64.length % 4) {
        base64 += '=';
    }
    return atob(base64);
}

function loadSerializedStateFromUrl() {
    const urlParams = new URLSearchParams(window.location.search);
    const encoded = urlParams.get('data');

    if (!encoded) {
        return;
    }

    try {
        let json = JSON.parse(base64UrlDecode(encoded));
        loadStateFromJSON(json, schemaTypes.SERIALIZED_STATE);
    } catch (e) {
        console.error("Failed to load state from URL:", e);
        return;
    }
}

function strictContext(obj, objName) {
    return new Proxy(obj, {
        get(target, prop) {
            if (!(prop in target)) {
                throw new Error(`Tried accessing an unknown property \`${prop}\` on the object \`${objName}\`.`);
            }

            const value = target[prop];

            if (value && typeof value === 'object') {
                return strictContext(value, `${objName}.${prop}`);
            }
            return value;
        }
    });
}

function generateStatementSafeHTML(boxName, statementIndex, assumedTrue) {
    const idPrefix = `${boxName}_s${statementIndex + 1}_${assumedTrue ? 'true' : 'false'}`;
    const codeInputId = `${idPrefix}_code`;
    const labelInputId = `${idPrefix}_label`;
    const code = document.getElementById(codeInputId)?.value || '';
    let label = document.getElementById(labelInputId)?.value || '';
    if (label.trim().length === 0 && !assumedTrue) {
        // if this is a false - those can often be empty from OCR since falses are hidden
        // so we try the true label too
        const trueLabelInputId = `${boxName}_s${statementIndex + 1}_true_label`;
        const trueLabel = document.getElementById(trueLabelInputId)?.value || '';
        if (trueLabel.trim().length > 0) {
            label = `(not true) ${trueLabel}`;
        }
    }

    let isDisplayingCode = label.trim().length === 0;
    let displaySafeHTML = isDisplayingCode ? `<code>\`${escapeHTML(code)}\`</code>` : escapeHTML(`"${label}"`);

    return {
        displaySafeHTML,
        code,
        label
    };
}


function calculate() {
    clearCalculations();
    generateCases();
    
    console.log("Calculating contradictions across all cases...");

    let allValidBoxIndexes = new Set();

    let nextCaseIndex = 0;
    for (let {combo, element} of state.cases) {
        let caseIndex = nextCaseIndex++;
        console.log(`\n\n\nEvaluating Case ${caseIndex + 1}\nBlue: ${combo[0].map(x => x ? 'TRUE' : 'FALSE').join(' / ')}\nWhite: ${combo[1].map(x => x ? 'TRUE' : 'FALSE').join(' / ')}\nBlack: ${combo[2].map(x => x ? 'TRUE' : 'FALSE').join(' / ')}`);

        let contradictionSafeHTMLs = [];
        let failedStatementsSet = new Set();
        let foundValidSubcaseInds = [];
        // we go through all sub-cases
        for (let gemsInBoxInd = 0; gemsInBoxInd < boxNames.length; gemsInBoxInd++) {
            console.log(`\nCase ${caseIndex + 1}, subcase ${gemsInBoxInd + 1}`);

            const boxPropsObjects = [];
            for (let i = 0; i < boxNames.length; i++) {
                const boxName = boxNames[i];
                let boxCombo = combo[i];
                const boxProps = {
                    color: boxName,
                    oneIsTrue: boxCombo.length > 0 ? boxCombo[0] === true : false,
                    oneIsFalse: boxCombo.length > 0 ? boxCombo[0] === false : false,
                    twoIsTrue: boxCombo.length > 1 ? boxCombo[1] === true : false,
                    twoIsFalse: boxCombo.length > 1 ? boxCombo[1] === false : false,
                    threeIsTrue: boxCombo.length > 2 ? boxCombo[2] === true : false,
                    threeIsFalse: boxCombo.length > 2 ? boxCombo[2] === false : false,
                    statements: boxCombo.map((v, j) => {
                        const labelId = `${boxName}_s${j + 1}_${v ? 'true' : 'false'}_label`;
                        const label = document.getElementById(labelId)?.value || '';
                        if (label.trim().length === 0) {
                            // we return the true version if it exists, as the false statements can be skipped by AI or humans
                            // JEXL expressions that need to read the statement will need just the true version anyway
                            const trueLabelId = `${boxName}_s${j + 1}_true_label`;
                            const trueLabel = document.getElementById(trueLabelId)?.value || '';
                            if (trueLabel.trim().length > 0) {
                                return trueLabel;
                            }
                            // if the true label is also empty, we just return empty
                            return '';
                        }
                        return label;
                    }),
                    bools: [...boxCombo],
                    isAllTrue: boxCombo.length === 0 ? false : boxCombo.every(v => v === true),
                    isAllFalse: boxCombo.length === 0 ? false : boxCombo.every(v => v === false),
                    isMixed: boxCombo.length === 0 ? false : boxCombo.some(v => v === true) && boxCombo.some(v => v === false),
                    trueCount: boxCombo.filter(v => v === true).length,
                    falseCount: boxCombo.filter(v => v === false).length,
                    isEmpty: gemsInBoxInd !== i,
                    hasGems: gemsInBoxInd === i
                }
                boxProps.isTrue = boxProps.isAllTrue;
                boxProps.isFalse = boxProps.isAllFalse;
                boxProps.allIsTrue = boxProps.isAllTrue;
                boxProps.allIsFalse = boxProps.isAllFalse;
                boxProps.hasNoGems = boxProps.isEmpty;
                boxProps.empty = boxProps.isEmpty;
                boxProps.notEmpty = boxProps.hasGems;
                boxProps.isNotEmpty = boxProps.hasGems;
                boxPropsObjects.push(boxProps);
            }
            const context = {
                trueBoxCount: boxPropsObjects.filter(box => box.isAllTrue).length,
                falseBoxCount: boxPropsObjects.filter(box => box.isAllFalse).length,
                trueStatementCount: boxPropsObjects.reduce((acc, box) => acc + box.trueCount, 0),
                falseStatementCount: boxPropsObjects.reduce((acc, box) => acc + box.falseCount, 0),
                boxWithGems: boxPropsObjects[gemsInBoxInd],
                boxesWithoutGems: boxPropsObjects.filter((_, index) => index !== gemsInBoxInd)
            }
            context.allTrueBoxCount = context.trueBoxCount;
            context.allFalseBoxCount = context.falseBoxCount;
            context.emptyBoxes = context.boxesWithoutGems;

            console.log(`Assuming ${capitalize(boxNames[gemsInBoxInd])} has gems:`, boxPropsObjects);

            // now we need to evaluate each of the statements of each box
            let foundContradiction = false;
            for (let boxIndex = 0; boxIndex < boxNames.length; boxIndex++) {
                const boxName = boxNames[boxIndex];
                const statementTruthsArray = combo[boxIndex];
                for (let statementIndex = 0; statementIndex < statementTruthsArray.length; statementIndex++) {
                    const assumedTrue = statementTruthsArray[statementIndex];
                    let { displaySafeHTML, label, code } = generateStatementSafeHTML(boxName, statementIndex, assumedTrue);

                    if (!code || code.trim() === '') {
                        // it's empty, we assume no contradiction
                        continue;
                    }

                    try {
                        const result = Jexl.evalSync(code, {
                            blue: strictContext(boxPropsObjects[0], 'blue'),
                            white: strictContext(boxPropsObjects[1], 'white'),
                            black: strictContext(boxPropsObjects[2], 'black'),
                            "this": strictContext(boxPropsObjects[boxIndex], 'this'),
                            context: strictContext(context, 'context')
                        });

                        console.log(`${capitalize(boxName)} ${statementIndex + 1} [${assumedTrue ? 'TRUE' : 'FALSE'}]: ${code} => ${!!result}`);

                        if (!result) {
                            foundContradiction = true;
                            failedStatementsSet.add(`${boxName}:${statementIndex}`);
                            contradictionSafeHTMLs.push(`If gems in ${capitalize(boxName)}:\n${displaySafeHTML}\nThat assumption derived from ${boxName} box ${statementIndex + 1} is a CONTRADICTION`);
                            break;
                        }
                    } catch (err) {
                        Swal.fire({
                            icon: 'error',
                            title: 'Error',
                            html: `Error evaluating the JS for ${escapeHTML(capitalize(boxName))} statement ${statementIndex + 1}:<br><br>${escapeHTML(err.message)}`
                        });
                        return;
                    }
                }

                if (foundContradiction) {
                    break;
                }
            }

            if (!foundContradiction) {
                foundValidSubcaseInds.push(gemsInBoxInd);
                console.log(`No contradictions in this sub-case, case ${caseIndex + 1} is valid if we assume ${capitalize(boxNames[gemsInBoxInd])} has gems!`);
            } else {
                console.log(`That's a contradiction. This sub-case is no good.`);
            }
        }

        let reasoningDiv = element.querySelector('.reasoning');
        let reasoningHeading = document.createElement('h4');
        reasoningDiv.appendChild(reasoningHeading);

        if (foundValidSubcaseInds.length === 0) {
            reasoningHeading.textContent = `Invalid case. Reasoning:`;

            console.log(`Case ${caseIndex + 1} is INVALID. All sub-cases (possible gem placements) lead to contradictions.`);
            element.classList.add('invalid-case');
            element.querySelectorAll('.stmt').forEach(span => {
                const boxName = span.dataset.boxName;
                const statementIndex = span.dataset.statementIndex;
                
                if (failedStatementsSet.has(`${boxName}:${statementIndex}`)) {
                    span.classList.add('highlight-false');
                } else {
                    span.classList.remove('highlight-false');
                }
            });
                
            const ol = document.createElement('ol');
            for (let i = 0; i < contradictionSafeHTMLs.length; i++) {
                const contradictionHTML = contradictionSafeHTMLs[i];
                const li = document.createElement('li');
                li.innerHTML = contradictionHTML;
                ol.appendChild(li);
            }
            reasoningDiv.appendChild(ol);
        } else {
            for (let index of foundValidSubcaseInds) {
                allValidBoxIndexes.add(index);
            }

            let validSubcaseString;
            if (foundValidSubcaseInds.length === 1) {
                reasoningHeading.textContent = `Valid case.`;
                validSubcaseString = `Case ${caseIndex + 1} is VALID if we assume the gems are in the ${uppercase(boxNames[foundValidSubcaseInds[0]])} box.`;
            } else {
                element.classList.add('ambiguous-case');
                reasoningHeading.textContent = `Ambiguous case.`;
                validSubcaseString = `Case ${caseIndex + 1} is ambiguous: it's valid if the gems are in either of the following boxes: ${foundValidSubcaseInds.map(ind => uppercase(boxNames[ind])).join(', ')}.`;
            }

            console.log(validSubcaseString);
            const span = document.createElement('span');
            span.textContent = validSubcaseString;
            reasoningDiv.appendChild(span);
        }
    }

    if (allValidBoxIndexes.size === 0) {
        document.getElementById('outcomeSummary').classList.remove('found-answer');
        document.getElementById('outcomeSummary').classList.remove('ambiguous-answer');
        document.getElementById('outcomeSummary').classList.add('no-answer');
        document.getElementById('outcomeText').textContent = 'No valid cases found. This should be impossible, please double-check your statements to ensure the logic checks are correct.';
    } else if (allValidBoxIndexes.size === 1) {
        document.getElementById('outcomeSummary').classList.remove('no-answer');
        document.getElementById('outcomeSummary').classList.remove('ambiguous-answer');
        document.getElementById('outcomeSummary').classList.add('found-answer');
        document.getElementById('outcomeText').textContent = `Based on the statements, the only possibility is that the gems are in the ${uppercase(boxNames[Array.from(allValidBoxIndexes)[0]])} box!`;
    } else {
        document.getElementById('outcomeSummary').classList.remove('no-answer');
        document.getElementById('outcomeSummary').classList.remove('found-answer');
        document.getElementById('outcomeSummary').classList.add('ambiguous-answer');
        document.getElementById('outcomeText').textContent = `The result is ambiguous, please either double-check that you have translated each of the logical statements to valid JS code, or alternatively check the cases manually to weed out some contradictions manually.\n\nBased on the statements, the gems could be in any of the following boxes: ${Array.from(allValidBoxIndexes).map(ind => uppercase(boxNames[ind])).join(', ')}.`;
    }

    document.getElementById('outcomeSummary').style.display = 'block';

    serializeStateToUrl();
}

function openCropModal() {
    document.getElementById('cropModal').style.display = 'block';
}

function closeCropModal() {
    document.getElementById('cropModal').style.display = 'none';
}

function handlePasteBoxPaste(event) {
    event.preventDefault();    
    const items = event.clipboardData.items;
    if (!items) {
        return;
    }

    let targetItem = null;
    for (const item of items) {
        if (item.type.startsWith('image/')) {
            targetItem = item;
            break;
        }
    }
    if (!targetItem) {
        return;
    }
    if (!state.cropper) {
        Swal.fire({
            icon: 'error',
            title: 'Cropper not loaded',
            text: 'Please wait for Cropper to load and try again.'
        });
        return;
    }

    const blob = targetItem.getAsFile();
    const url = URL.createObjectURL(blob);
    state.cropper.getCropperImage().src = url;
    state.cropper.getCropperSelection().$clear();
    state.currentCropperBoxName = event.target.dataset.boxName;
    document.getElementById('cropModal').style.display = 'block';

    event.target.textContent = 'Screenshot captured, yet to be cropped. Click and use Ctrl + V to override';
}

function parseOcrResult(text) {
    // returns a list of statements (maximum of maxPossibleStatements)

    // we split by . and replace all newlines with spaces
    text = text.replace(/\n/g, ' ').replace(/ +/g, ' ').trim();

    let statements = text.split('.').map(s => s.trim()).filter(s => s.length > 0);
    statements = statements.map(el => el + '.');

    // if it's more than 3, we do [0, 1, concat(2..3..4..) etc]
    if (statements.length > maxPossibleStatements) {
        const merged = statements.slice(0, maxPossibleStatements - 1);
        const remaining = statements.slice(maxPossibleStatements - 1).join(' ');
        merged.push(remaining);
        statements = merged;
    }

    return statements;
}

async function runOCR(base64, boxName) {
    Swal.fire({
        title: 'OCR in progress',
        html: `<div id="ocr-progress">Initializing...</div>`,
        allowOutsideClick: false,
        didOpen: () => {
            Swal.showLoading();
        }
    });

    let pasteBox = document.querySelector(`.paste-box[data-box-name="${boxName}"]`);

    try {
        const ocrResult = await Tesseract.recognize(base64, 'eng', {
            logger: m => {
                if (m.status === 'recognizing text') {
                    const pct = Math.round(m.progress * 100);
                    const text = `Recognizing text (${pct}%)`;
                    document.getElementById('ocr-progress').textContent = text;
                } else {
                    document.getElementById('ocr-progress').textContent = capitalize(m.status) + '...';
                }
            }
        });

        // we process it and use THAT as the new result
        // processing it again should result in the same result, so if the user doesn't edit anything, it would work fine, too
        // the user COULD edit it to anything though, so we do process it again afterwards
        let textResult = parseOcrResult(ocrResult.data.text).join('\n');

        const result = await Swal.fire({
            icon: 'success',
            title: 'OCR Complete',
            html: `<p>You may edit the result before it's processed into statements. Each statement's end is denoted with a dot and a newline.</p><textarea id="ocr-edit-area" style="width:100%;height:200px;">${escapeHTML(textResult)}</textarea>`,
            showCancelButton: true,
            confirmButtonText: 'Accept',
            cancelButtonText: 'Discard',
            reverseButtons: true,
            preConfirm: () => {
                const textarea = document.getElementById('ocr-edit-area');
                return textarea ? textarea.value : textResult;
            }
        });

        if (result.isConfirmed) {
            onOcrAccept(result.value, boxName);
            pasteBox.textContent = 'Box screenshot processed, labels filled in\n(Click, then Ctrl + V to override)';
        } else {
            pasteBox.textContent = 'Paste box screenshot here to autofill\n(Click, then Ctrl+V)';
        }
    } catch (err) {
        console.error(err);
        Swal.fire({
            icon: 'error',
            title: 'OCR Failed',
            text: 'Could not process image text.'
        });

        pasteBox.textContent = 'OCR failed, try again? Paste box screenshot here to autofill\n(Click, then Ctrl+V)';
    }
}

function onOcrAccept(text, boxName) {
    let statements = parseOcrResult(text);
    
    // if the number of statements is not equal to the current number of statements, we simulate a click on the button with the right count
    //   and regenerate the inputs
    const currentCount = getStatementsCount(boxName);
    if (statements.length != currentCount) {
        const group = document.querySelector(`.button-group[data-name="${boxName}Count"]`);
        const toggleButton = group.querySelector(`.toggle-button[data-value="${statements.length}"]`);
        if (toggleButton) {
            toggleButton.click();
        }
        generateInputs();
    }

    // we fill in the statement labels. we automatically toggle them on so that the user can see the statements were loaded.
    toggleOptionalLabelInputs(true);

    for (let i = 0; i < statements.length; i++) {
        const statement = statements[i];
        const labelId = `${boxName}_s${i + 1}_true_label`;
        const codeId = `${boxName}_s${i + 1}_true_code`;
        const labelEl = document.getElementById(labelId);
        const codeEl = document.getElementById(codeId);
        if (labelEl) {
            labelEl.value = statement;
        }
    }

    // we generate the URL
    serializeStateToUrl();
}

document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.button-group').forEach(group => {
        group.addEventListener('click', (e) => {
            if (e.target.classList.contains('toggle-button')) {
                group.querySelectorAll('.toggle-button').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
            }

            // we also regenerate the inputs when the toggle buttons are clicked
            generateInputs();
        });
    });

    document.querySelectorAll('.show-hide-label-btn').forEach(button => {
        button.addEventListener('click', () => {
            const shouldShow = button.dataset.value === "1";
            toggleOptionalLabelInputs(shouldShow);
        });
    });

    document.querySelectorAll('.show-hide-negation-btn').forEach(button => {
        button.addEventListener('click', () => {
            const shouldShow = button.dataset.value === "1";
            toggleNegations(shouldShow);
        });
    });

    document.getElementById('cropConfirm').onclick = async () => {
        if (!state.cropper) {
            Swal.fire({
                icon: 'error',
                title: 'Cropper not loaded',
                text: 'Please wait for Cropper to load and try again.'
            });
            return;
        }

        const selection = state.cropper.getCropperSelection();
        const width = selection.width;
        const height = selection.height;

        // we auto scale it since tesseract struggles with small images
        const TARGET_WIDTH = 512;
        const scaleFactor = TARGET_WIDTH / width;
        const outputWidth = TARGET_WIDTH;
        const outputHeight = Math.round(height * scaleFactor);

        const canvas = await selection.$toCanvas({
            width: outputWidth,
            height: outputHeight
        });
        const base64 = canvas.toDataURL('image/png');
        closeCropModal();

        await runOCR(base64, state.currentCropperBoxName);
    }

    generateInputs();
    loadSerializedStateFromUrl();
    state.cropper = new Cropper('#cropImage', {
        viewMode: 1,
        autoCropArea: 1,
        movable: true,
        zoomable: true,
        rotatable: false,
        scalable: false,
    });
});
</script>
</html>
